/****************************************************************************************
* RyRFit is a program designed to place boxes with the correct dimensions and orientation
* at the positions of RyR tetramers in tomographic images of dyads of mammalian cardiomyocytes.
* The images, which  are in the TIFF format, consist of sequential parallel planes, betwen 0.5
* and 1 nm apart, through the plane of the dyad and are generated by the Amira program (Thermo
* Fisher Scientific - FEI). The tetramer is represented by an open rectangle with a default width
* of 27 nm (which can be changed).
*
* Tetramers are placed manually and can then be classified according to the scheme in
* Asghari et. al. Circ. Res. 115(2) 252-66, 2014. The program also calculates nearest
* neighbour distances as well as an alpha shape and a convex hull around the dyad, allowing
* and estimate of the area and the density (tetramers per unit area).
*
* Copyright David Scriven, 2012-2021.
*
* Moore Laboratory, Life Sciences Institute,  2350 Health Sciences
* Mall, University of British Columbia, Vancouver, Canada, V6T 1Z3
*
* This file, interface.cpp, is part of the RyRFit program
*
* RyRFit links to the proprietary Qt system (currently ver 5.15.2) as well as the the free
* CGAL algorithmic library and the free TIFF library. On Windows it links to the Visual C++
* redistributable
*
* RyRFit is free software: you can redistribute it and/or modify it under the terms of the
* GNU General Public License as published by the Free Software Foundation, either version 3 of
* the License, or any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with RyRFit.  If not, see <https://www.gnu.org/licenses/>.
*
**********************************************************************************************/
#include "interface.h"
#include "ryr_fit4.h"
#include "tiff6qt.h"
#include <QCollator>
#include <QDir>
#include <QScrollBar>
#include <QFileDialog>
#include <QInputDialog>
#include <QValidator>
#include <QMessageBox>
#include <QFileInfo>
#include <QSettings>
#include <QString>
#include <QIcon>
#include <QDesktopServices>
#include <QStringBuilder>
#include <QSound>

QPoint  em_interface::RyRFitPosn;
QString em_interface::TetramerFile;
QString em_interface::NNDFile;
QString em_interface::TiffOutputRoot;
std::vector<Tetramer> em_interface::tm;
GLubyte* em_interface::texelplanes;
GLushort* em_interface::texelplanes16bit;

em_interface::em_interface(QSize Screensize, qreal Screendpi)
{
    setupUi(this);
    setModal(false);
    setWindowFlags(Qt::CustomizeWindowHint | Qt::WindowTitleHint);
    setWindowIcon(QIcon(":/RyRFit.ico"));

    FileNames.clear();
    imageVal = new QSettings(QSettings::IniFormat, QSettings::UserScope, "MooreLabUBC", "RyRFit");
    leNmPerPixel->setValidator(new QDoubleValidator( 0.2, 3.0, 2, leNmPerPixel));

    IsFileLoaded = false;
    bFileScale = false;
    bEnteredScale = false;
    enteredscale = 0.0;
    filescale = 0.0;
    fnmPerPixel = 0.0;

    QString LastDir = imageVal->value("ImageDir", "").toString();
    if(LastDir.isEmpty())
       LastDir = QDir::homePath();

    DirectoryName = LastDir;
    Analyse = nullptr;
    texelplanes = nullptr;
    texelplanes16bit = nullptr;

    rbMultiStack->setChecked(true);
    bMultiImage = false;
    lblInputType->setText("Name");
    bOldData=false;

    Analyse = new RyRFit;
    Analyse->setScreenParam(Screensize, Screendpi);

    connect(Analyse, SIGNAL(AlertMsg(QString,char)), this, SLOT(setAlert(QString,char)));
    connect(Analyse, SIGNAL(ClosePgm()), this, SLOT(Close()));
    connect(Analyse, SIGNAL(NewBasePixelSize(double)), this, SLOT(displayPixelSize(double)));
    connect(Analyse, SIGNAL(showHelp()), this, SLOT(showHelp()));
    connect(pbLoad, SIGNAL(pressed()), this, SLOT(LoadPressed()));
    connect(pbClose, SIGNAL(pressed()), this, SLOT(Close()));
    connect(pbBrowseFiles, SIGNAL(pressed()), this, SLOT(BrowsePressed()));
    connect(rbImageStack, SIGNAL(toggled(bool)), this, SLOT(ToggleStack()));
    connect(leNmPerPixel, SIGNAL(inputRejected()), this, SLOT(BadPixelSize()));

    pbLoad->setEnabled(false);
    sb = teMessage->verticalScrollBar();
    QPoint initposn = QPoint(5,10);
    RyRFitPosn = QPoint(initposn.x()+frameGeometry().width() +3, initposn.y());
    QRect boxg = geometry();
    setGeometry(initposn.x(), initposn.y(), boxg.width(), boxg.height());
}
void em_interface::resetSystem()
{
    if(texelplanes != nullptr)
    {
        delete [] texelplanes;
        texelplanes = nullptr;
    }
    if(texelplanes16bit != nullptr)
    {
        delete [] texelplanes16bit;
        texelplanes16bit = nullptr;
    }
    IsFileLoaded = false;
    bFileScale = false;
    bEnteredScale = false;
    enteredscale = 0.0;
    filescale = 0.0;
    fnmPerPixel = 0.0;

    tm.clear();
    leImageFileDirectory->clear();
    leNmPerPixel->setReadOnly(false);
    leNmPerPixel->clear();
    FileNames.clear();
    Directory->clear();
    WindowTitle.clear();
    pbLoad->setEnabled(false);
}
void em_interface::keyPressEvent(QKeyEvent* e)
{
    switch( e->key() )
    {
    case Qt::Key_Escape:
        Close();
        break;
    case Qt::Key_F1:
        showHelp();
        break;
    }
}
void em_interface::showHelp()
{
    QString HelpFile = "file:///" % QDir::currentPath() % "/help/index.html";
    QDesktopServices::openUrl(QUrl(HelpFile, QUrl::TolerantMode));
}
void em_interface::BrowsePressed()
{
    if(IsFileLoaded)
    {
        if(!Analyse->isFileSaved())
            Analyse->saveTetramerFiles();
        resetSystem();
    }
    else
    {
      if(pbLoad->isEnabled())
        resetSystem();
    }

    QString FileNameRoot;
    if(bMultiImage)
    {
        DirectoryName = QFileDialog::getExistingDirectory(this, tr("Open Directory"),DirectoryName,
                                                          QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

        if(DirectoryName.isNull())
            return;
        QDir em_directory(DirectoryName);
        Directory->clear();
        leImageFileDirectory->setText(DirectoryName);
        QStringList images = em_directory.entryList(QStringList() << "*.tif" << "*.TIF" << "*.tiff" << "*.TIFF",QDir::Files);
        QCollator collator;
        collator.setNumericMode(true);
        std::sort(images.begin(), images.end(), collator);
        int nImages = images.size();
        std::vector<uint> imsizes;
        std::vector<uint> imsort;
        for(int k=0; k < nImages; k++)
        {
            QString fn=DirectoryName+'/'+images.at(k);
            QFileInfo fi(fn);
            imsizes.push_back(uint(fi.size()));
        }
        imsort = imsizes;
        std::nth_element(imsort.begin(),imsort.begin() + imsort.size()/2, imsort.end());
        uint sizemedian = imsort[imsort.size()/2];
        QString fns;
        for(int k=0; k < nImages; k++)
        {
            if((imsizes[k] < 1.4*sizemedian) && (imsizes[k] > 0.6*sizemedian))
            {
                QString fn = images.at(k);
                fns += fn + " ";
                QString fullfn=DirectoryName+'/'+fn;
                FileNames.push_back(fullfn);
            }
        }
        setAlert("****************** New File *********************",'m');
        setAlert(QString("Files to be loaded from stack: %1").arg(fns),'g');
        FileNameRoot = DirectoryName % "/";
        TiffOutputRoot = FileNameRoot % QString("Fitted");
        QStringList ifs = fns.split(" ",Qt::SkipEmptyParts);
        QString firstfile = QString(ifs.at(0)).remove(".tif");
        WindowTitle = DirectoryName % "/" % firstfile % "-" % ifs.at(ifs.size()-1);
    }
    else
    {
        QString ImageFilename =  QFileDialog::getOpenFileName( this,"Open TIFF file", DirectoryName, "TIFF files (*.tif *.tiff)"); // *.TIF *.TIFF)");
        if(ImageFilename.isNull())
            return;
        QFileInfo q(ImageFilename);
        DirectoryName=q.path();
        FileNameRoot = DirectoryName % "/" % q.baseName();
        TiffOutputRoot = FileNameRoot % QString("_fitted");
        QString DirectoryMinName=DirectoryName;
        int pos = qMax(0,DirectoryMinName.indexOf("My Documents"));
        Directory->setText(DirectoryName.mid(pos));
        FileNames.push_back(ImageFilename);
        leImageFileDirectory->setText(q.completeBaseName());
        WindowTitle = ImageFilename;
        setAlert("****************** New File *********************",'m');
    }

    Analyse->HideScreen();
    pbBrowseFiles->clearFocus();
    pbLoad->setEnabled(true);
    IsFileLoaded = false;

    TetramerFile= FileNameRoot % QString("_tetramer.dat");

    NNDFile= FileNameRoot % QString("_nnd.dat");

    ReadTetramerFile();
}
void em_interface::LoadPressed()
{
    setCursor(Qt::WaitCursor);
    bool bRet = ReadFiles();
    setCursor(Qt::ArrowCursor);
    if(!bRet)
    {
        resetSystem();
        return;
    }
    pbLoad->setEnabled(false);
    IsFileLoaded = true;
    setAlert("==========================================",'m');
    setAlert(QString("Displaying %1").arg(WindowTitle),'m');
    Analyse->Display(nXdim, nYdim, nNoImages, float(fnmPerPixel), b16bit, WindowTitle);
}
void em_interface::ToggleStack()
{
    if(IsFileLoaded && !(Analyse->isFileSaved()))
       Analyse->saveTetramerFiles();

    resetSystem();

    if(rbImageStack->isChecked())
    {
        bMultiImage = true;
        lblInputType->setText("Directory");
    }
    else
    {
        bMultiImage = false;
        lblInputType->setText("Name");
    }
}
bool em_interface::ReadFiles()
{
    if(!CheckDimAndType())return false;

    int nNoRGBTexels = nXdim*nYdim*nNoImages*4;

    switch(nBitsPerSample)
    {
    case 8:
        b16bit = false;
        texelplanes = new GLubyte[nNoRGBTexels];
        texelplanesst = texelplanes;
        break;
    case 16:
        b16bit = true;
        texelplanes16bit = new GLushort[nNoRGBTexels];
        texelplanes16bitst = texelplanes16bit;
        break;
    default:
        setAlert(QString("TIFF file has invalid bits per sample = %1").arg(nBitsPerSample),'r');
        return false;
        break;
    }

    bool bRTS= ReadTiffStack();

    if(nBitsPerSample == 8)
        texelplanes = texelplanesst;
    else
        texelplanes16bit = texelplanes16bitst;

    if(!bRTS)
      return false;

    pbLoad->setEnabled(false);
    return true;
}
bool em_interface::ReadTetramerFile()
{
    bEnteredScale = false;
    QString PixelSize = leNmPerPixel->text();
    if(!PixelSize.isEmpty())
    {
        bEnteredScale = true;
        enteredscale = PixelSize.toDouble();
    }

    bFileScale =false;
    filescale = 0.0;
    uint nT = 0;
    QFileInfo dfi(TetramerFile);
    if(dfi.exists())
    {
        QFile file(TetramerFile);
        if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            setAlert(QString("Error - cannot read Tetramer file - reason %1").arg(file.errorString()),'r');
            return false;
        }
        else
        {
            QTextStream input(&file);
            uint tno=1;
            forever
            {
                QString tline=input.readLine();
                if(tline.isEmpty())
                   break;
                if(tline.contains("scale"))
                {
                    filescale=(tline.remove("scale=")).toFloat();
                    bFileScale = true;
                }
                else
                {
                    QStringList tl=tline.split(" ",Qt::SkipEmptyParts);
                    Tetramer itm;
                    itm.xcentre = tl.at(0).toFloat();
                    itm.ycentre = tl.at(1).toFloat();
                    itm.angle = tl.at(2).toInt();
                    itm.classification = tl.at(3).at(0).toLatin1();
                    itm.tno = tno++;
                    tm.push_back(itm);
                }
            }
            file.close();
            nT = uint(tm.size());
            if(nT == 0)
               setAlert("No valid tetramers in file",'m');
            else
               setAlert(QString("%1 tetramers in input").arg(nT),'m');
        }

    }
    else
       setAlert(QString("No tetramer file present"),'m');

    if(bEnteredScale)
    {
        if(bFileScale)
        {
            QString info="";

            if(std::abs(filescale - enteredscale) > 0.01)
            {
                info = QString("Scaling within file is %1 while entered scale is %2\nPlease enter the correct scale (nm/pixel):")
                        .arg(filescale).arg(enteredscale);
                bool ok;
                double newScale = QInputDialog::getDouble(this,"Scaling mismatch", info, filescale, 0.1, 3.0, 2, &ok);
                if(!ok)
                {
                    fnmPerPixel = filescale;
                    setAlert(QString("Reset Pixel Size to %1").arg(fnmPerPixel),'m');
                } else {
                    fnmPerPixel = newScale;
                    setAlert(QString("Reset Pixel Size to %1").arg(fnmPerPixel),'m');
                }
            }
        }
        else
          fnmPerPixel = enteredscale;
    }
    else
    {
        if(bFileScale)
            fnmPerPixel = filescale;
        else
        {
            bool ok;
            double newScale = QInputDialog::getDouble(this, "Missing Scale", "No scale supplied\nPlease enter the scale (nm/pixel):",
                                                         1.0, 0.1, 2, 3.0, &ok);
            if(!ok)
            {
                fnmPerPixel = 1.0;
                setAlert(QString("Setting Pixel Size to 1.00").arg(fnmPerPixel),'m');
            } else {
                fnmPerPixel = newScale;
                setAlert(QString("Pixel Size set to %1").arg(fnmPerPixel),'m');
            }
        }
    }

    bEnteredScale = false;
    leNmPerPixel->setText(QString("%1").arg(fnmPerPixel,0,'f',2));
    leNmPerPixel->setReadOnly(true);
    return true;
}
void em_interface::displayPixelSize(double PixelSize)
{
    leNmPerPixel->setText(QString("%1").arg(PixelSize,0,'f',2));
    setAlert(QString("Pixel Size changed to %1").arg(PixelSize),'m');
}
void em_interface::BadPixelSize()
{
    setAlert("Invalid Pixel Size - must be between 0.2 and 3.0 nm", 'r');
    leNmPerPixel->setText(QString("%1").arg(fnmPerPixel,0,'f',2));
}
void em_interface::setAlert(QString msg, char color)
{
    if(color == 'c')
        msg = "<font color=cyan>" + msg + "</font>";
    if(color == 'g')
        msg = "<font color=green>" + msg + "</font>";
    if(color == 'o')
        msg = "<font color=orange>" + msg + "</font>";
    if(color == 'r')
    {
#ifdef __WIN32__
        QSound::play(":/Error.wav");
#endif
        msg = "<font color=red>" + msg + "</font>";
    }
    if(color == 'b')
        msg = "<font color=blue>" + msg + "</font>";
    if(color == 'm')
        msg = "<font color=magenta>" + msg + "</font>";

    teMessage->append(msg);
    sb->setValue(sb->maximum());
}
bool em_interface::CheckDimAndType()
{
    int nXdim0 = 0;
    int nYdim0 = 0;
    int nZdim0 = 0;
    int nInputType0 = -1;
    int nXdim1 = 0;
    int nYdim1 = 0;
    int nInputType1 = -1;

    for(uint i=0; i < FileNames.size(); i++)
    {
        QString fname=FileNames[i];
        QFileInfo fi(fname);
        if(fi.suffix().isEmpty())
            FileNames[i] += QString(".tif");

        TiffImage* imfile = new TiffImage;
        if(!imfile->ReadTiff(FileNames[i].toLocal8Bit().data(),true))
        {
            setAlert(QString("Error while reading in file parameters for %1").arg(FileNames[i]),'r');
            delete imfile;
            return false;
        }
        if(i == 0)
        {
            setAlert(QString("File parameters for %1 :").arg(FileNames[i]),'b');
            nXdim0 = imfile->Xdim();
            nYdim0 = imfile->Ydim();
            nInputType0=imfile->InputType();
            nZdim = imfile->Zdim();
            nZdim0 += nZdim;
            setAlert(QString("Size: %1 x %2 x %3").arg(nXdim0).arg(nYdim0).arg(nZdim),'b');
            QString DateandTime=imfile->DateandTime();
            if(!DateandTime.isEmpty())
            {
                QString Year=DateandTime.mid(0,4);
                QString Month=DateandTime.mid(5,2);
                QString Day=DateandTime.mid(8,2);
                QString Time=DateandTime.mid(11,8);
                DateandTime = "Date: " + Day + '/' + Month + '/' + Year + " - Time: " + Time;
                setAlert(QString("%1").arg(DateandTime),'b');
            }

            nBitsPerSample = imfile->BitsPerSample();
            QString ImageInfo = QString("%1 bits/pixel").arg(nBitsPerSample);
            switch (nInputType0)
            {
            case 1:
            case 5:
                ImageInfo += " grayscale image";
                ImageType = MONO;
                break;
            case 2:
            case 3:
                ImageInfo +=  " RGB image";
                ImageType = RGB;
                break;
            case 4:
            case 8:
                ImageInfo +=  " RGBA image";
                ImageType = RGB;
                break;
            default:
                ImageInfo +=  " Invalid type";
                ImageType = INVALID;
                setAlert(QString("Cannot handle TIFF file with PhotometricInterpretation of %1").arg(imfile->Photometric()),'r');
                break;
            }
            setAlert(ImageInfo,'b');
//            nX0 = imfile->X0();
//            nY0 = imfile->Y0();
        }
        if(ImageType == INVALID)
        {
            delete imfile;
            return false;
        }

        if(i > 0)
        {

            nXdim1 = imfile->Xdim();
            nYdim1 = imfile->Ydim();
            nInputType1 = imfile->InputType();

            if(nXdim0 != nXdim1 || nYdim0 != nYdim1)
            {
                setAlert(QString("Error - X & Y dimensions are different - files %1 and %2 of stack ").arg(i-1).arg(i),'r');
                return false;
            }
            if(nInputType0 != nInputType1)
            {
                setAlert(QString("Error - Input types are different - files %1 and %2 of stack ").arg(i-1).arg(i),'r');
                return false;
            }
        }
        delete imfile;
    }
    nXdim = nXdim0;
    nYdim = nYdim0;
    nNoImages = nZdim0;
    nInputType = nInputType0;

    return true;
}
void em_interface::InputTiffMono(TiffImage* Tiff_Image)
{

    int nDataPoints=Tiff_Image->PntsPerImage();
    bool bMinisWhite = Tiff_Image->WhiteisMin();

    if(nBitsPerSample == 8)
    {
        GLubyte pb1;
        GLubyte *pb = Tiff_Image->BytePointer();
        for(int k = 0; k < nDataPoints; k++)
        {
            if(bMinisWhite)
                pb1 = 255 - *pb++;
            else
                pb1 = *pb++;

            *texelplanes++ = pb1;
            *texelplanes++ = pb1;
            *texelplanes++ = pb1;
            *texelplanes++ = 255;
        }
    }
    else
    {
        GLushort ps1;
        GLushort *ps = Tiff_Image->UShortPointer();
        for(int k = 0; k < nDataPoints; k++)
        {
            if(bMinisWhite)
                ps1 = 65535 - *ps++;
            else
                ps1 = *ps++;

            *texelplanes16bit++ = ps1;
            *texelplanes16bit++ = ps1;
            *texelplanes16bit++ = ps1;
            *texelplanes16bit++ = 255;
        }
    }

}
void em_interface::InputTiffRGB(TiffImage* Tiff_Image)
{
    int nDataPoints=Tiff_Image->PntsPerImage();

    if(nBitsPerSample == 8)
    {
        //       cerr << "\nInput = 8 bit RGB\n";
        GLubyte *pb = Tiff_Image->BytePointer();

        for(int k = 0; k < nDataPoints; k++)
        {
            *texelplanes++ = *pb++;
            *texelplanes++ = *pb++;
            *texelplanes++ = *pb++;
            *texelplanes++ = 255;
        }
    }
    else
    {
        GLushort *ps = Tiff_Image->UShortPointer();
        //       cerr << "\nInput = 16 bit RGB\n";

        for(int k = 0; k < nDataPoints; k++)
        {
            *texelplanes16bit++ = *ps++;
            *texelplanes16bit++ = *ps++;
            *texelplanes16bit++ = *ps++;
            *texelplanes16bit++ = 255;
        }
    }
}
bool em_interface::InputTiffMap(TiffImage* Tiff_Image)
{
    int nDataPoints=Tiff_Image->PntsPerImage();

    GLushort* r;
    GLushort* g;
    GLushort* b;
    Tiff_Image->ColourMap(r, g, b);
    int num_entries = 1 << Tiff_Image->BitsPerSample() ;

    if(nBitsPerSample == 8)
    {
        //       cerr << "\nInput = 8 bit Map\n";
        GLubyte *pb = Tiff_Image->BytePointer();

        for(int k = 0; k < nDataPoints; k++)
        {
            if(*pb >= num_entries)
            {
                setAlert(QString(" Error - value of %1 exceeds number of entries in lookup table = %2").arg(*pb).arg(num_entries),'r');
                return false;
            }
            *texelplanes++ = *(r + *pb);
            *texelplanes++ = *(g + *pb);
            *texelplanes++ = *(b + *pb);
            *texelplanes++ = 255;
            pb++;
        }
    }
    else
    {
        GLushort *ps = Tiff_Image->UShortPointer();
        //       cerr << "\nInput = 16 bit Map\n";

        for(int k = 0; k < nDataPoints; k++)
        {
            if(*ps >= num_entries)
            {
                setAlert(QString(" Error - value of %1 exceeds number of entries in lookup table = %2").arg(*ps).arg(num_entries),'r');
                return false;
            }
            *texelplanes16bit++ = *(r + *ps);
            *texelplanes16bit++ = *(g + *ps);
            *texelplanes16bit++ = *(b + *ps);
            *texelplanes16bit++ = 255;
            ps++;
        }
    }

    return true;
}
bool em_interface::ReadTiffStack()
{
    uint nNoFiles = uint(FileNames.size());
    for(uint m = 0; m < nNoFiles; m++)
    {
        QFileInfo a(FileNames[m]);
        QString fn=a.fileName();
        TiffImage*  Tiff_Image = new TiffImage;
        setAlert(QString("Reading file %1 ...").arg(fn),'b');
        if(!Tiff_Image->ReadTiff(FileNames[m].toLocal8Bit().data()))
        {
            setAlert(QString("Error while reading in file %1").arg(FileNames[m]),'r');
            delete Tiff_Image;
            return false;
        }

        switch(ImageType)
        {
        case MONO:
            InputTiffMono(Tiff_Image);
            break;
        case RGB:
            InputTiffRGB(Tiff_Image);
            break;
        case PALETTE:
            InputTiffMap(Tiff_Image);
            break;
        }

        delete Tiff_Image;
    }
    setAlert(QString("Read %1 File(s) and %2 images").arg(nNoFiles).arg(nNoImages),'b');
    return true;
}
void em_interface::closeEvent(QCloseEvent *e)
{
    if(IsFileLoaded && !(Analyse->isFileSaved()))
       Analyse->saveTetramerFiles();

    int ret = QMessageBox::question(this, "RyRFit", "Are you sure you want to close the program?");
    if(ret == QMessageBox::No)
    {
       e->ignore();
       return;
    }
    if(Analyse->isVisible())
       Analyse->close();

    imageVal->setValue("ImageDir", DirectoryName);
    resetSystem();
    delete Analyse;
    e->accept();
}
void em_interface::Close()
{
    close();
}


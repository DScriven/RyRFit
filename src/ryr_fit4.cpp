/****************************************************************************************
* RyRFit is a program designed to place boxes with the correct dimensions and orientation
* at the positions of RyR tetramers in tomographic images of dyads of mammalian cardiomyocytes.
* The images, which  are in the TIFF format, consist of sequential parallel planes, betwen 0.5
* and 1 nm apart, through the plane of the dyad and are generated by the Amira program (Thermo
* Fisher Scientific - FEI). The tetramer is represented by an open rectangle with a default width
* of 27 nm (which can be changed).
*
* Tetramers are placed manually and can then be classified according to the scheme in
* Asghari et. al. Circ. Res. 115(2) 252-66, 2014. The program also calculates nearest
* neighbour distances as well as an alpha shape and a convex hull around the dyad, allowing
* and estimate of the area and the density (tetramers per unit area).
*
* Copyright David Scriven, 2023.
*
* Moore Laboratory, Life Sciences Institute,  2350 Health Sciences
* Mall, University of British Columbia, Vancouver, Canada, V6T 1Z3
*
* This file, ryr_fit4.cpp, is part of the RyRFit program
*
* RyRFit links to the proprietary Qt system (currently ver 5.15.2) as well as the the free
* CGAL algorithmic library and the free TIFF library. On Windows it links to the Visual C++
* redistributable.
*
* RyRFit is free software: you can redistribute it and/or modify it under the terms of the
* GNU General Public License as published by the Free Software Foundation, either version 3 of
* the License, or any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with RyRFit.  If not, see <https://www.gnu.org/licenses/>.
*
**********************************************************************************************/
#include <QtGui>
#include <QtGlobal>
#include <QDesktopWidget>
#include <QTextStream>
#include <QRegExp>
#include <QStringList>
#include <QMenu>
#include <QInputDialog>
#include <QFileDialog>
#include <QSurfaceFormat>
#include <QOpenGLShaderProgram>
#include <QOpenGLVertexArrayObject>
#ifdef GL_DEBUG
#include <QOpenGLDebugLogger>
#include <QOpenGLDebugMessage>
#endif
#include <QByteArray>
#include <QMatrix4x4>
#include <QPainter>
#include <iostream>
#include <istream>
#include "ryr_fit4.h"
#include "tiff6qt.h"
#include <cstdlib>
#include <cmath>
#include <iomanip>

#include <CGAL/algorithm.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Alpha_shape_2.h>
#include <CGAL/Polygon_2.h>
#include <CGAL/convex_hull_2.h>

#include <vector>

typedef G::FT FT;
typedef CGAL::Polygon_2<G> Polygon_2;
typedef CGAL::Alpha_shape_vertex_base_2<G> Vb;
typedef CGAL::Alpha_shape_face_base_2<G>  Fb;
typedef CGAL::Triangulation_data_structure_2<Vb,Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<G,Tds> DT;
typedef CGAL::Alpha_shape_2<DT> Alpha_shape_2;
typedef Alpha_shape_2::Alpha_shape_edges_iterator Alpha_shape_edges_iterator;

using namespace std;

RyRFit::RyRFit(): QOpenGLWindow()
{
    basefont = QFont("Arial",8,QFont::Bold);
    setFlag(Qt::CustomizeWindowHint);
    setFlag(Qt::WindowTitleHint);

    imageMenu = new QMenu(nullptr);

    tetrameroutline = nullptr;
    scalebar = nullptr;
    tetplot = nullptr;

    degtorad=4.0*atan(1.0)/180.0;
    tetramersize=27;
    sqrt2 = sqrt(2.0);
    fortyfivedeg = 45.0 * degtorad;
    tetramerwidth = tetramersize;
    tetramerdiag = tetramerwidth/sqrt2;
    bLookAhead = false;
    bFirstTime = true;

    tl_start = nullptr;
    tl_count = nullptr;

    hullpts = nullptr;
    alphapts = nullptr;

    planeimage = nullptr;
    boundary = nullptr;
    scalebar = nullptr;
    tetplot = nullptr;
    ImageOffset = Point_2(0.,0.);
}
RyRFit::~RyRFit()
{
    std::vector<NNDval>().swap(NNDtet);

    if(planeimage != nullptr)
    {
        delete planeimage;
        planeimage = nullptr;
    }
    if(boundary != nullptr)
    {
        delete boundary;
        boundary = nullptr;
    }
    if(scalebar != nullptr)
    {
        delete scalebar;
        scalebar = nullptr;
    }
    if(tetplot != nullptr)
    {
        delete tetplot;
        tetplot = nullptr;
    }
    makeCurrent();

    hull_vbo.destroy();
    scalebar_vbo.destroy();
    tetramers_vbo.destroy();
    singletetramer_vbo.destroy();
    doneCurrent();

    delete [] hullpts;
    delete [] alphapts;
    delete [] tetrameroutline;

    delete [] tl_start;
    delete [] tl_count;

    delete imageMenu;
//    delete ScaleVal;
}
void RyRFit::initValues()
{
    CUD_Colours[0] = QVector3D(0.0f,0.0f,0.0f);           // black
    CUD_Colours[1] = QVector3D(0.902f, 0.624f, 0.0f);    // orange
    CUD_Colours[2] = QVector3D(0.337f, 0.706f, 0.913f);  // skyblue
    CUD_Colours[3] = QVector3D(0.0f, 0.62f, 0.451f);      // bluegreen
    CUD_Colours[4] = QVector3D(0.941f, 0.894f, 0.259f);  // yellow
    CUD_Colours[5] = QVector3D(0.f, 0.447f, 0.698f);     // blue
    CUD_Colours[6] = QVector3D(0.835f, 0.369f, 0.f);      // vermillion
    CUD_Colours[7] = QVector3D(0.8f, 0.475f, 0.655f);    // redpurple

    bLinePlot = false;
    bLeftButtonDown=false;   //mousebutton status
    bEnteredScale = false;
    bScaleBar = false;
    bScaleBarPositionChosen = false;
    bLookAhead = false;

    bSavedTetFile = true;
    bCalcNearestNeighbours = false;
    bShowNearestNeighbours = false;
    bModifyTetramer = false;
    bAddTetramer = false;
    bClassifyTetramer = false;
    bPlacingTetramer = false;
    bDisplayNND = false;
    bRedColourOnly = false;
    bHideEMImage = false;
    bShadow = false;

    bScaleBar = false;     // Show a scalebar?
    bShowTetramers = false;
    bShowArea = false;
    bDisplayHulls = false;
    fFlipImage = 1.0;
    fFlipBoxes = -1.0;
 
    bShowArea = false;
    fZoom = 1.0f;
    fZoomDelta = 0.2f;

    bRightButtonDown=false;
    bMiddleButtonDown=false;
    bAltPressed = false;

    nImagedTetramers = 0;
    nBeingModified = -1;
    nBeingClassified = -1;

    nLookAhead = 0;
    nPalette = 1;
    Palette1();
    fXScreenMax = ScreenSize.width()-550;
    fYScreenMax = ScreenSize.height()-80;

    totalConvexArea=0.0;
    totalAlphaArea=0.0;
}
 void RyRFit::Palette1()
 {
    PlacingColour = QVector3D(1.0f,1.0f,1.0f);
    UnlabeledColour =  CUD_Colours[vermillion];
    ChkrboardColour =  CUD_Colours[skyblue];
    SidebySideColour =  CUD_Colours[orange];
    IsolatedColour = CUD_Colours[bluegreen];
    BothColour = CUD_Colours[redpurple];
    ScaleBarColour = QVector4D(PlacingColour,1.0);

    NNDlineColour = Qt::white;
    NNDtextColour = Qt::white;
}
void RyRFit::Palette2()
{
    PlacingColour = QVector3D(0.0,0.0,0.0);
    UnlabeledColour = QVector3D(1.0,0.0,0.0);
    ChkrboardColour = QVector3D(0.0f,1.0f,0.0f);
    SidebySideColour = QVector3D(1.0,1.0,0.0);
    IsolatedColour = QVector3D(0.0,1.0,1.0);
    BothColour = QVector3D(1.0,0.0,1.0);
    ScaleBarColour = QVector4D(PlacingColour,1.0);

    NNDlineColour = Qt::green;
    NNDtextColour = Qt::green;
 }
void RyRFit::CloseWindow()
{
    if(bPlacingTetramer || bModifyTetramer || bClassifyTetramer)
    {
        emit AlertMsg("Cannot close program while adding, modifying or classifying tetramers",'r');
        return;
    }
    emit ClosePgm();
}
void RyRFit::contextMenuEvent(QContextMenuEvent *e)
{
    QMenu* menu;

    menu=imageMenu;

    menu->exec(e->globalPos());
}
void RyRFit::keyPressEvent( QKeyEvent *e )
{
    if(bModifyTetramer || bAddTetramer)
    {
        ValidAddModifyKeys(e);
        return;
    }
    if(bClassifyTetramer)
    {
        ValidClassifyKeys(e);
        return;
    }
    switch( e->key() )
    {
    case Qt::Key_Escape:
        CloseWindow();
        break;
    case Qt::Key_Home:
        imageFirstPlane();
        break;
    case Qt::Key_End:
        imageLastPlane();
        break;
    case Qt::Key_Right:
        imageNextPlane();
        break;
    case Qt::Key_Left:
        imagePrevPlane();
        break;
    case Qt::Key_A:
        addTetramer();
        break;
    case Qt::Key_C:
        classifyTetramer();
        break;
    case Qt::Key_D: //Distance Measure
        imageLine();
        break;
    case Qt::Key_H:
        hideEMImage();
        break;
    case Qt::Key_K: //LookAhead
        changeLookAhead();
        break;
    case Qt::Key_L: //LookAhead
        LookAhead();
        break;
    case Qt::Key_M:
        modifyTetramer();
        break;
    case Qt::Key_N:
        showNearestNeighbours();
        break;
    case Qt::Key_R:
        showExtent();
        break;
    case Qt::Key_Z:
        resetDisplay();
        break;
    case Qt::Key_F1:
        emit showHelp();
        break;
    case Qt::Key_F2:
        displayTetramers();
        break;
    case Qt::Key_F3:
        showRedTetramers();
        break;
    case Qt::Key_F4:
        changeTetramerHighlight();
        break;
    case Qt::Key_F5:
        saveTetramerFiles();
        break;
    case Qt::Key_F6:
        getScaleBarSize();
        break;
    case Qt::Key_F7:
        CreateScreenShot();
        break;
    case Qt::Key_F8:
        changePalette();
        break;
    case Qt::Key_F9:
        changeImageScaling();
        break;
    case Qt::Key_F10:
        OutputNNDs();
        break;
    case Qt::Key_F11:
        ChangeTetramerWidth();
        break;
    case Qt::Key_F12:
        FlipImage();
        break;
    case Qt::Key_Plus:  // Zoom In
        fZoomDelta = 0.2f;
        if (e->modifiers() & Qt::AltModifier)
            fZoomDelta = 0.5f;
        if (e->modifiers() & Qt::ControlModifier)
            fZoomDelta = 1.0f;
        imageZoomIn();
        break;
    case Qt::Key_Minus: // Zoom Out
        fZoomDelta = 0.2f;
        if (e->modifiers() & Qt::AltModifier)
            fZoomDelta = 0.5f;
        if (e->modifiers() & Qt::ControlModifier)
            fZoomDelta = 1.0f;
        imageZoomOut();
        break;
        case Qt::Key_Alt:
    case Qt::Key_AltGr:
        bAltPressed = true;
        break;
    default:
        break;
    }
}
void RyRFit::ValidAddModifyKeys(QKeyEvent *e)
{
    switch( e->key() )
    {
    case Qt::Key_Escape:
        setCursor(Qt::ArrowCursor);
        if(bAddTetramer)
        {
            bAddTetramer = false;
            if(bPlacingTetramer)
            {
                emit AlertMsg(QString("Tetramer not added"),'r');
                bPlacingTetramer = false;
                loadTetramerData();
                update();
              }
            return;
        }
        if(bModifyTetramer)
        {
            bModifyTetramer = false;
            if(nBeingModified > -1)
            {
                emit AlertMsg(QString("Tetramer %1 NOT modified").arg(nBeingModified + 1),'r');
                nBeingModified = -1;
                loadTetramerData();
                update();
            }
            return;
        }
        break;
    case Qt::Key_Right:
        ntm.xcentre += 1;
        loadSingleTetramerData();
        break;
    case Qt::Key_Left:
        ntm.xcentre -= 1;
        loadSingleTetramerData();
        break;
    case Qt::Key_Up:
        ntm.ycentre += 1;
        loadSingleTetramerData();
        break;
    case Qt::Key_Down:
        ntm.ycentre -= 1;
        loadSingleTetramerData();
        break;
    case Qt::Key_D:
        deleteTetramer();
        break;
    case Qt::Key_S:
        saveTetramer();
        break;
    default:
        emit AlertMsg(QString("Invalid key %1 during add/modify").arg(e->text()),'r');
        break;
    }
}
void RyRFit::ValidClassifyKeys(QKeyEvent *e)
{
    switch( e->key() )
    {
    case Qt::Key_Escape:
        setCursor(Qt::ArrowCursor);
        bClassifyTetramer = false;
        if(nBeingClassified > -1)
        {
           emit AlertMsg(QString("Tetramer %1 NOT classified").arg(nBeingClassified + 1),'r');
           nBeingClassified = -1;
           loadTetramerData();
           update();
        }
        return;
        break;
    case Qt::Key_B:
        tetramerClassification('b');
        break;
    case Qt::Key_C:
        tetramerClassification('c');
        break;
    case Qt::Key_E:
        bClassifyTetramer = false;
        nBeingClassified = -1;
        loadTetramerData();
        update();
        break;
    case Qt::Key_I:
        tetramerClassification('i');
        break;
    case Qt::Key_S:
        tetramerClassification('s');
        break;
    case Qt::Key_U:
        tetramerClassification('u');
        break;
    default:
        emit AlertMsg(QString("Invalid key %1 for classification").arg(e->text()),'r');
        break;
    }
}
void RyRFit::keyReleaseEvent( QKeyEvent *e )
{
    if(e->key() == Qt::Key_Alt || e->key() == Qt::Key_AltGr)
        bAltPressed = false;
}
void RyRFit::mousePressEvent( QMouseEvent *e )
{
    if(bPlacingTetramer || (nBeingModified > -1) || (nBeingClassified > -1))
    {
        emit AlertMsg("Cannot press mouse buttons while adding, modifying or classifying tetramers",'r');
        return;
    }

    Point_2 mousePosn= LimitMouse(e->x(),e->y());
    Point_2 ImagePt = to2DObjectPoint(mousePosn);
    StartImagePt = ImagePt;
//    emit AlertMsg(QString("Mouse Posn at Start = (%1, %2)").arg(mousePosn.x()).arg(mousePosn.y()),'r');
    switch (e->button())
    {
     case Qt::LeftButton:
        StartPt = EndPt = mousePosn;
        bLeftButtonDown = true;
        if(bModifyTetramer || bClassifyTetramer)
        {
            setCursor(Qt::ArrowCursor);
//            emit AlertMsg(QString("Classifying tetramer at %1,%2").arg(ImagePt.x()).arg(ImagePt.y()), 'b');
            if(!findTetramer(ImagePt))
                return;
        }
        if(bAddTetramer)
        {
            setCursor(Qt::ArrowCursor);
            ntm.xcentre = ImagePt.x();
            ntm.ycentre = ImagePt.y();
            ntm.angle = 0.0;
 //           emit AlertMsg(QString("Adding tetramer at %1,%2").arg(ntm.xcentre).arg(ntm.ycentre), 'b');
            bPlacingTetramer = true;
            loadSingleTetramerData();
            update();
            return;
        }
        if(bLinePlot)
            setCursor(Qt::CrossCursor);
        else
            setCursor(Qt::SizeHorCursor);

        break;
     case Qt::MiddleButton:
        if(bScaleBar && !bScaleBarPositionChosen)
        {
          ScaleBarPosition = to2DObjectPoint(mousePosn);
          bScaleBarPositionChosen = true;
          CalculateScaleBar();
        }
        break;
    case Qt::RightButton:
        imageMenu->exec(e->globalPos());
        break;
    default:
        QWindow::mousePressEvent(e);
        break;
    }
}
void RyRFit::mouseReleaseEvent( QMouseEvent *e )
{
    EndPt = LimitMouse(e->x(), e->y());
    EndImagePt = to2DObjectPoint(EndPt);
//    emit AlertMsg(QString("Mouse Posn on Release = (%1, %2)").arg(EndImagePt.x()).arg(EndImagePt.y()),'r');

    switch (e->button())
    {
    case Qt::LeftButton:
        bLeftButtonDown=false;
        if(bLinePlot)
        {
            if(StartPt != EndPt)
                update();
        }
        break;
     default:
        QWindow::mouseReleaseEvent(e);
        break;
    }
    unsetCursor();
}
void RyRFit::mouseMoveEvent( QMouseEvent *e )
{
    Point_2 newMousePosn = LimitMouse(e->x(),e->y());
//    Point_2 newImagePosn = to2DObjectPoint(newMousePosn);
//    emit AlertMsg(QString("Mouse Posn on Move = (%1, %2)").arg(newImagePosn.x()).arg(newImagePosn.y()),'r');

    if(bLeftButtonDown)
    {
        if(bLinePlot)
        {
            EndPt = newMousePosn;
//   emit AlertMsg(QString("New Mouse Posn = (%1, %2)").arg(newMousePosn.x()).arg(newMousePosn.y()),'r');
            update();
        }
        else
        {
            int nXmove = newMousePosn.x() - mousePosn.x();

            if(nXmove > 0)
                imageNextPlane();

            if(nXmove < 0)
                imagePrevPlane();

            mousePosn = newMousePosn;
            update();
        }
    }
 }
void RyRFit::wheelEvent(QWheelEvent *event)
{
    if(bPlacingTetramer || bModifyTetramer)
    {
        ntm.angle += int(event->angleDelta().y()/20);
        ntm.angle %= 90;
        loadSingleTetramerData();
    }
}
Point_2 RyRFit::LimitMouse(int x, int y)
{
    // Transform y coordinate
    if(x < 0) x = 0;
    else if(x > ImageXdim-1)x = ImageXdim-1;

    if(y < 0)y = 0;
    else if(y > ImageYdim-1)y = ImageYdim-1;

    return Point_2(x, y);
}
void RyRFit::changeImageScaling()
{
    bool ok;
    double newScale=QInputDialog::getDouble(nullptr,"New Image Scale", "Enter Image Scale (0.1-3.0)", ImageScale, 0.1, 3.0, 2, &ok);
    if(!ok)
       return;

    emit NewImageScale(newScale);
    ImageScale = newScale;
    PixelSize = ImageScale/fZoom;
    bSavedTetFile = false;
    loadTetramerData();
    if((nBeingModified > -1)|| (nBeingClassified > -1))
        loadSingleTetramerData();
    if(bDisplayHulls)
        calculateArea();
    update();
}
void RyRFit::HideScreen()
{
    hide();
}
void RyRFit::Display(int nX, int nY, int nI, float NmPerPixel, bool b16, QString ImWindowTitle)
{
    InitXdim = nX;
    InitYdim = nY;
    b16bit = b16;
    NoImages = nI;
    nZmin = 0;
    nZmax = NoImages-1;
    ImageNo=nZmin;

    initValues();
    ImageScale = NmPerPixel;
    PixelSize = ImageScale;
    ImageOffset = Point_2(0,0);
    changeProjection(1.0,1.0);
    changeScalingandTranslation(0.,0.);
    InitCentre = Centre;

    ImageXdim = InitXdim;
    ImageYdim = InitYdim;
    nNoTetramers = uint(em_interface::tm.size());
    if(nNoTetramers == 0)  // to save pixel size
       bSavedTetFile = false;

    tno = nNoTetramers + 1;
    //  Parameters for image window

    basefont = QFont("Cantrill",11);
    tinyfont = QFont("Cantrill",8);

    if(!bFirstTime)
    {
      delete [] hullpts;
      delete [] alphapts;
      delete [] tetrameroutline;

      delete [] tl_start;
      delete [] tl_count;

      tl_start = nullptr;
      tl_count = nullptr;

      hullpts = nullptr;
      alphapts = nullptr;
      tetrameroutline = nullptr;

      resize(InitXdim,InitYdim);
      if(nNoTetramers > 0)
      {
         loadTetramerData();
         bShowTetramers = true;
      }
      glDeleteTextures(1,&em_images);
      createTextures();
      update();
    }
    else
    {
      setGeometry(0,0,InitXdim,InitYdim);
      createActions();
      createMenus();
      bFirstTime = false;
    }
    show();
    setTitle(ImWindowTitle);
    setFramePosition(em_interface::RyRFitPosn);
}
void RyRFit::changePalette()
{
    if(bModifyTetramer ||  bPlacingTetramer || bClassifyTetramer)
       return;
    if(nPalette == 1)
       nPalette = 2;
    else
       nPalette = 1;

    if (nPalette == 1)
       Palette1();
    else
       Palette2();
     if(bShowTetramers)
       loadTetramerData();

    update();
}
void RyRFit::OutputNNDs()
{
    Save_DisplayNNDFiles();
}
void RyRFit::changeLookAhead()
{
    if(bLookAhead)
    {
      nLookAhead = QInputDialog::getInt(nullptr,"LookAhead Value","Enter No Images to lookAhead", nLookAhead, 1, NoImages, 1);
      update();
    }
}
void RyRFit::LookAhead()
{
    bLookAhead = !bLookAhead;

    if(bLookAhead)
      nLookAhead = QInputDialog::getInt(nullptr,"LookAhead Value","Enter No Images to lookAhead", nLookAhead, 1, NoImages, 1);
    else
      nLookAhead = 0;

    update();
}
void RyRFit::getScaleBarSize()
{
    if(bPlacingTetramer || (nBeingModified > -1) || (nBeingClassified > -1))
    {
        emit AlertMsg("Can't place a scalebar when adding, modifying or classifying a tetramer",'r');
        return;
    }
    bScaleBar=!bScaleBar;
    bScaleBarPositionChosen = false;
    if(bScaleBar)
    {
      int minsize=20;
      nScaleBarLength=QInputDialog::getInt(nullptr,"ScaleBar Value","Enter Scalebar length (nm)", nScaleBarLength, minsize, 500, 10);
    }
    else
      update();
}
void RyRFit::initializeGL()
{
    QSurfaceFormat format;
    format.setDepthBufferSize( 24 );
    format.setSamples(24);
    format.setVersion(4,3);
    format.setRenderableType(QSurfaceFormat::OpenGL);
    setFormat(format);
    initializeOpenGLFunctions();
    makeCurrent();

    const char* Renderer = reinterpret_cast<const char *>(glGetString(GL_RENDERER));
    emit AlertMsg(QString("Renderer : %1").arg(Renderer),' ');
    std::string Vendor = reinterpret_cast<const char *>(glGetString(GL_VENDOR));
    emit AlertMsg(QString("Vendor : %1").arg(Vendor.c_str()),' ');
    if(Vendor.find("NVIDIA") != std::string::npos)
    {
        int GPU_Memory;
        glGetIntegerv(GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX, &GPU_Memory);
        QString unit = " kB";
        if (GPU_Memory > 100000)
        {
           GPU_Memory /= 1024;
           unit = " MB";
        }
        emit AlertMsg(QString("GPU memory available is %1 %2").arg(GPU_Memory).arg(unit),' ');
    }
    const char* Version = reinterpret_cast<const char *>(glGetString(GL_VERSION));
    emit AlertMsg(QString("Open GL version = %1").arg(Version),' ');

#ifdef GL_DEBUG
    QOpenGLContext *ctx = QOpenGLContext::currentContext();
    if(ctx->hasExtension(QByteArrayLiteral("GL_KHR_debug")))
    {
      GLlogger = new QOpenGLDebugLogger(this);
      GLlogger->initialize();
      connect(GLlogger, &QOpenGLDebugLogger::messageLogged, this, [&](const QOpenGLDebugMessage& message)
                 { RyRFit::debugMessageHandler(message); });
      GLlogger->startLogging(QOpenGLDebugLogger::SynchronousLogging);
      emit AlertMsg("OpenGL logging started",'r');
    }
    else
      emit AlertMsg("OpenGL logging not available",'r');
#endif
    initShaders();
}
#ifdef GL_DEBUG
void RyRFit::debugMessageHandler(const QOpenGLDebugMessage& debugMessage)
{
    auto severity = debugMessage.severity();
    char mColor='g';
    switch (severity) {
        case QOpenGLDebugMessage::NotificationSeverity:
        case QOpenGLDebugMessage::LowSeverity:
            break;
        default:
            mColor ='r';
            break;
    }
    emit AlertMsg(QString("Open GL: %1").arg(debugMessage.message()),mColor);
    return;
}
#endif
void RyRFit::createTextures()
{
    glGenTextures(1,&em_images);
    glBindTexture(GL_TEXTURE_2D_ARRAY,em_images);
    if(b16bit)
    {
       glTexStorage3D(GL_TEXTURE_2D_ARRAY, 1, GL_RGBA16, InitXdim, InitYdim, NoImages);
       glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0, 0, InitXdim, InitYdim, NoImages, GL_RGBA, GL_UNSIGNED_SHORT, em_interface::texelplanes16bit);
    }
    else
    {
       glTexStorage3D(GL_TEXTURE_2D_ARRAY, GLsizei(1), GL_RGBA8, InitXdim, InitYdim, NoImages);
       glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0, 0, InitXdim, InitYdim, NoImages, GL_RGBA, GL_UNSIGNED_BYTE, em_interface::texelplanes);
    }
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
}
void RyRFit::CalculateScaleBar()
{
    Point_2 sy1 = to2DObjectPoint(Point_2(0.0,0.0));
    Point_2 sy2 = to2DObjectPoint(Point_2(0.0,12.0));
    float sbht=float(sy1.y()-sy2.y());
    Point_2 st = ScaleBarPosition;
    ScaleBar[0] = QVector2D(st.x(), st.y());
    ScaleBar[1] = QVector2D(st.x(), st.y() + sbht);
    ScaleBar[2] = QVector2D(st.x() + (nScaleBarLength/PixelSize), st.y());
    ScaleBar[3] = QVector2D(st.x() + (nScaleBarLength/PixelSize), st.y() + sbht);
    scalebar_vbo.bind();
    scalebar_vbo.allocate(ScaleBar, int(4 * sizeof(QVector2D)));
    scalebar_vbo.release();
    update();
}
template <class T>
T RyRFit::to2DViewportPoint(T posn)
{
    QVector4D rp = QVector4D(posn.x(),posn.y(),0.0f,1.0f);
    QVector4D rt = transform*rp;
    int newx = int(InitXdim*(rt.x()+1.0f)/2.0f);
    int newy = int(InitYdim*(1.0f-(rt.y()+1.0f)/2.0f));
    return (T(newx, newy));
}
template <class T>
T RyRFit::to2DObjectPoint(T posn)
{
    float newx = (2.0f*(float(posn.x()))/InitXdim) - 1.0f;
    float newy = (2.0f*(InitYdim-float(posn.y()))/InitYdim) - 1.0f;
    QVector4D rp = QVector4D(newx,newy,0.0,1.0);
    QVector4D rt = invtransform*rp;
    return (T(rt.x(), rt.y()));
}
void RyRFit::changeScaling()
{
    scaling.setToIdentity();
    scaling.scale(fZoom,fFlipBoxes*fZoom,1.0);
    transform=scaling*orthoproj*translation;
    invtransform = transform.inverted();
}
void RyRFit::changeTranslation(float xs, float ys)
{
    translation.setToIdentity();
    translation.setColumn(3,QVector4D(xs,ys,0.0,1.0));
    transform=scaling*orthoproj*translation;
    invtransform = transform.inverted();
}
void RyRFit::changeScalingandTranslation(float xs, float ys)
{
    scaling.setToIdentity();
    scaling.scale(fZoom,fFlipBoxes*fZoom,1.0);
    translation.setToIdentity();
    translation.setColumn(3,QVector4D(xs,ys,0.0,1.0));
    transform=scaling*orthoproj*translation;
    invtransform = transform.inverted();
}
void RyRFit::changeProjection(float xm, float ym)
{
    ImageSize = QRectF(0., 0., float(xm*InitXdim), float(ym*InitYdim));
    orthoproj.setToIdentity();
    orthoproj.ortho(ImageSize);
    float NewXCentre = ImageSize.width()/2.0;
    float NewYCentre = ImageSize.height()/2.0;
    Centre = Point_2(NewXCentre, NewYCentre);
    ImageOffset = Point_2(NewXCentre - InitCentre.x(), fFlipImage*(NewYCentre - InitCentre.y()));
}
void RyRFit::resetDisplay()
{
    fZoom=1.0f;
    ImageOffset = Point_2(0.0f,0.0f);
    changeProjection(1.0f,1.0f);
    changeScalingandTranslation(0.0,0.0);
    resize(InitXdim,InitYdim);
    PixelSize = ImageScale;
    emit AlertMsg(QString("Image Reset: Zoom = %1 - PixelSize = %2 nm").arg(fZoom).arg(PixelSize,0,'f',2),'m');
    update();
}
void RyRFit::initShaders()
{
    planeimage = new QOpenGLShaderProgram();

    if(!planeimage->addShaderFromSourceFile(QOpenGLShader::Vertex, ":/planeimage.vert"))
    {
       emit AlertMsg("Error when compiling the planeimage vertex shader",'r');
       emit AlertMsg(QString(planeimage->log()),'r');
       return;
    }

    if(!planeimage->addShaderFromSourceFile(QOpenGLShader::Fragment, ":/planeimage.frag"))
    {
        emit AlertMsg("Error when compiling the planeimage fragment shader",'r');
        emit AlertMsg(QString(planeimage->log()),'r');
        return;
    }
    if(!planeimage->link())
    {
       emit AlertMsg("Error when linking the planeimage shader program",'r');
       emit AlertMsg(QString(planeimage->log()),'r');
       return;
    }

    vao_image.create();
    vao_image.bind();

    createTextures();

    vao_image.release();

    boundary = new QOpenGLShaderProgram();

    if(!boundary->addShaderFromSourceFile(QOpenGLShader::Vertex, ":/boundaries.vert"))
    {
       emit AlertMsg("Error when compiling the segment vertex shader",'r');
       emit AlertMsg(QString(boundary->log()),'r');
       return;
    }

    if(!boundary->addShaderFromSourceFile(QOpenGLShader::Fragment, ":/colours.frag"))
    {
        emit AlertMsg("Error when compiling the segment fragment shader",'r');
        emit AlertMsg(QString(boundary->log()),'r');
        return;
    }
    if(!boundary->link())
    {
       emit AlertMsg("Error when linking the boundary shader program",'r');
       emit AlertMsg(QString(boundary->log()),'r');
       return;
    }

    boundary->bindAttributeLocation("alphapts", 0);
    boundary->bind();

    TransformBoundaryLoc=boundary->uniformLocation("transform");
    BoundaryColourLoc=boundary->uniformLocation("BoundaryColour");

    vao_alpha.create();
    vao_alpha.bind();

    alpha_vbo.create();
    alpha_vbo.bind();
    alpha_vbo.setUsagePattern(QOpenGLBuffer::DynamicDraw);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(QVector2D), nullptr);
    alpha_vbo.release();
    vao_alpha.release();

    vao_hull.create();
    vao_hull.bind();

    hull_vbo.create();
    hull_vbo.bind();
    hull_vbo.setUsagePattern(QOpenGLBuffer::DynamicDraw);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(QVector2D), nullptr);
    hull_vbo.release();
    vao_hull.release();

    vao_scalebar.create();
    vao_scalebar.bind();

    scalebar_vbo.create();
    scalebar_vbo.bind();
    scalebar_vbo.setUsagePattern(QOpenGLBuffer::DynamicDraw);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(QVector2D), nullptr);
    scalebar_vbo.release();
    vao_scalebar.release();

    // tetramer plot

     tetplot = new QOpenGLShaderProgram();

    if(!tetplot->addShaderFromSourceFile(QOpenGLShader::Vertex, ":/tetramers.vert"))
    {
       emit AlertMsg("Error when compiling the tetramer vertex shader",'r');
       emit AlertMsg(QString(tetplot->log()),'r');
       return;
    }

    if(!tetplot->addShaderFromSourceFile(QOpenGLShader::Fragment, ":/colours.frag"))
    {
       emit AlertMsg("Error when compiling the tetramer fragment shader",'r');
       emit AlertMsg(QString(tetplot->log()),'r');
       return;
    }
    tetplot->bindAttributeLocation("tetramers", 0);

    if(!tetplot->link())
    {
       emit AlertMsg("Error when linking the tetramer shader program",'r');
       emit AlertMsg(QString(tetplot->log()),'r');
       return;
    }

    tetplot->bind();

    vao_tetramers.create();
    vao_tetramers.bind();

    tetramers_vbo.create();
    tetramers_vbo.bind();
    tetramers_vbo.setUsagePattern(QOpenGLBuffer::DynamicDraw);

    std::size_t toff = offsetof(tetramerimage,linecolour);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(tetramerimage), nullptr);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(tetramerimage), reinterpret_cast<GLvoid*>(toff));

    TransformTetramerLoc=tetplot->uniformLocation("transform");
    TransparencyLoc=tetplot->uniformLocation("transparency");

    loadTetramerData();

    tetramers_vbo.release();
    vao_tetramers.release();

// singletetramer

    vao_singletetramer.create();
    vao_singletetramer.bind();

    singletetramer_vbo.create();
    singletetramer_vbo.bind();
    singletetramer_vbo.setUsagePattern(QOpenGLBuffer::DynamicDraw);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(tetramerimage), nullptr);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(tetramerimage), reinterpret_cast<GLvoid*>(toff));

    singletetramer_vbo.release();
    vao_singletetramer.release();
}
void RyRFit::paintGL()
{
    if(bShowArea || bDisplayNND)
    {
        bLookAhead = false;
        nLookAhead = 0;
    }
    GLint tetline = GL_LINE_LOOP;
    float transparency=1.0f;
    QPainter p(this);
    p.beginNativePainting();
    if(bShadow)
    {
        tetline = GL_QUADS;
        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
        transparency = 0.5f;
    }
    if(bLookAhead)
    {
       glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
//       glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
    }
    else
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

    glClear(GL_COLOR_BUFFER_BIT);
    glLineWidth(1.0f);

    int nBackMost = NoImages - 1;
    if(!bHideEMImage)
    {
        float fTransparency = 1.0f;
        glUseProgram(planeimage->programId());
        vao_image.bind();
        glVertexAttrib1fv(1,&fFlipImage);
        if(bLookAhead)
        {
           glEnable(GL_BLEND);
           glBlendEquation(GL_MIN);
           nBackMost = min(ImageNo+nLookAhead, NoImages-1);
           fTransparency = 1.0f;
           glVertexAttrib1fv(2,&fTransparency);
           for(int i2 = nBackMost; i2 >= ImageNo; i2--)
           {
               glVertexAttribI1i(0, i2);
               glDrawArrays(GL_TRIANGLE_STRIP,0,4);
           }
           glBlendEquation(GL_FUNC_ADD);
           glDisable(GL_BLEND);
        }
        else
        {
          glVertexAttrib1fv(2,&fTransparency);
          glVertexAttribI1i(0, ImageNo);
          glDrawArrays(GL_TRIANGLE_STRIP,0,4);
        }
        vao_image.release();
    }
    if((bShowArea && bDisplayHulls) || bScaleBar)
    {
        glUseProgram(boundary->programId());
        boundary->setUniformValueArray(TransformBoundaryLoc,&transform, 1);
    }

    if(bShowArea && bDisplayHulls)
    {
        glLineWidth(2.0);
        vao_hull.bind();
        BoundaryColour=QVector4D(1.0,0.0,1.0,1.0);
        boundary->setUniformValue(BoundaryColourLoc, BoundaryColour);
        glDrawArrays(GL_LINE_LOOP,0,hl_count);
        vao_hull.release();

        vao_alpha.bind();
        BoundaryColour=QVector4D(0.0,0.0,1.0,1.0);
        boundary->setUniformValue(BoundaryColourLoc, BoundaryColour);
        glDrawArrays(GL_LINES,0,al_count);
        vao_alpha.release();
        glLineWidth(1.0);
    }

    if(bScaleBar)
    {
        vao_scalebar.bind();
        boundary->setUniformValue(BoundaryColourLoc, ScaleBarColour);
        glDrawArrays(GL_TRIANGLE_STRIP,0,4);
        vao_scalebar.release();
    }

    if(bShowTetramers)
    {
        glUseProgram(tetplot->programId());
        tetplot->setUniformValueArray(TransformTetramerLoc,&transform, 1);
        tetplot->setUniformValue(TransparencyLoc, 1.0f);
        if(bPlacingTetramer || bModifyTetramer || bClassifyTetramer)
        {
            vao_singletetramer.bind();
            glDrawArrays(GL_LINE_LOOP,0,4);
            vao_singletetramer.release();
        }
        if(nImagedTetramers > 0)
        {
            tetplot->setUniformValue(TransparencyLoc, transparency);
            if(bShadow)
                glEnable(GL_BLEND);
            else
                glLineWidth(1.5f);
            vao_tetramers.bind();
            glMultiDrawArrays(tetline,tl_start,tl_count,GLsizei(nImagedTetramers));
            vao_tetramers.release();
            if(bShadow)
                glDisable(GL_BLEND);
            else
                glLineWidth(1.5f);
        }
    }

    p.endNativePainting();

    QString info0 = "";
    if(abs(float(tetramersize) - 27.0f) > FLT_EPSILON)
        info0 = QString("Tetramer width: = %1 nm; ").arg(tetramersize);
    QString info;
    QString info2;
    info=QString("Zoom: %1; Pixel: %2 nm; ").arg(fZoom,0,'f',2).arg((PixelSize),0,'f',2);

    if(bLookAhead)
        info2=QString("Planes: %1 - %2").arg(ImageNo + 1).arg(nBackMost + 1);
    else
        info2=QString("Plane: %1").arg(ImageNo+1);
    info=info0 % info % info2;

    p.setPen(Qt::red);
    p.setFont(basefont);
    p.drawText(50, 25,info);

    if(nPalette == 1)
    {
        NNDlineColour = Qt::white;
        NNDtextColour = Qt::white;
    }
    else
    {
        NNDlineColour = Qt::green;
        NNDtextColour = Qt::green;
    }

    if(bDisplayNND)
    {
        p.setFont(tinyfont);

        for (uint i = 0; i < NNDtet.size(); i++)
        {
            Point_2 p1 = to2DViewportPoint(NNDtet[i].NNDStart);
            p1=Point_2(p1.x()*fZoom,p1.y()*fZoom);
            Point_2 p2 = to2DViewportPoint(NNDtet[i].NNDEnd);
            p2=Point_2(p2.x()*fZoom,p2.y()*fZoom);
            p.setPen(QPen(NNDlineColour,0));
            p.drawLine(QPointF(p1.x(),p1.y()),QPointF(p2.x(),p2.y()));
            float xpos = ((p1.x()+p2.x())/2 - 4) - 8;
            float ypos = ((p1.y()+p2.y())/2);
            p.setPen(NNDtextColour);
            p.drawText(xpos, ypos, QString::number(NNDtet[i].NND,'f',1));
        }
    }

    if(bLinePlot && EndPt != StartPt)
    {
        p.setPen(Qt::red);
        p.setFont(tinyfont);
        QString LineVal = "";

        p.drawLine(QPointF(StartPt.x(),StartPt.y()),QPointF(EndPt.x(),EndPt.y()));
        Point_2 StartL = to2DObjectPoint(StartPt);
        Point_2 EndL = to2DObjectPoint(EndPt);
        char mu = char(0xb5);
        double dXdist= double(EndL.x() - StartL.x());
        double dYdist= double(EndL.y() - StartL.y());
        double dDist = sqrt(dXdist*dXdist + dYdist*dYdist)*PixelSize;

        if(dDist > 1000.0)
            LineVal = QString("%1 %2m").arg(QString::number(dDist/1000.0, 'g',3)).arg(mu);
        else
            LineVal = QString("%1 nm").arg(int(dDist));

        p.drawText(int(StartPt.x() + (EndPt.x() - StartPt.x())/2) , int(StartPt.y() + (EndPt.y() - StartPt.y())/2 + 20), LineVal);
    }

    if(bShowArea)
    {
        p.setFont(basefont);
        p.setPen(Qt::red);
        info=QString("%1 Tetramers").arg(nNoTetramers);
        p.drawText(50, 45, info);
        info=QString("Convex Hull : cover  %1 % of the area - density =  %2 nm-2").arg(percentTetramerAreaConvex,0,'f',1).arg(TetramerDensityConvex,0,'e',2);
        p.drawText(50, 65, info);
        info=QString("Alpha Shape : cover  %1 % of the area - density =  %2 nm-2").arg(percentTetramerAreaAlpha,0,'f',1).arg(TetramerDensityAlpha,0,'e',2);
        p.drawText(50, 85, info);
    }

    p.end();
}
void RyRFit::imageLine()
{
    bLinePlot = !bLinePlot;
    if(bLinePlot)
        StartPt = EndPt = Point_2(0.0f,0.0f);

    update();
}
void RyRFit::loadTetramerData()
{
    if(tl_start != nullptr)
    {
        delete[] tl_start;
        delete[] tl_count;
        delete[] tetrameroutline;
        tl_start = nullptr;
        tl_count = nullptr;
        tetrameroutline = nullptr;
    }
    nNoTetramers = uint(em_interface::tm.size());
    if(nNoTetramers == 0)
        return;
    nImagedTetramers = nNoTetramers;
    if(nBeingModified > -1 || nBeingClassified > -1)
        nImagedTetramers--;
    if(nImagedTetramers == 0)
        return;

    imageindex = 0;

    tl_start = new GLint[size_t(nImagedTetramers)];
    tl_count = new GLsizei[size_t(nImagedTetramers)];
    tetrameroutline = new tetramerimage[size_t(nImagedTetramers*4)];
    QVector3D tcolor;
    uint j = 0;
    for(int i = 0; i < int(nNoTetramers); i++)
    {
        if(i == nBeingModified || i == nBeingClassified)
            continue;
        else
        {
            if(bRedColourOnly)
                tcolor=QVector3D(1.0,0.0,0.0);
            else
            {
                switch(em_interface::tm[i].classification)
                {
                case 'u':
                    tcolor=UnlabeledColour;
                    break;
                case 'c':
                    tcolor=ChkrboardColour;
                    break;
                case 's':
                    tcolor=SidebySideColour;
                    break;
                case 'i':
                    tcolor=IsolatedColour;
                    break;
                case 'b':
                    tcolor=BothColour;
                    break;
                default:
                    tcolor=PlacingColour;
                }
            }
            calcTetramer(em_interface::tm[i],tcolor, tetrameroutline);
        }
        tl_start[j]=GLint(j*4);
        tl_count[j]=GLsizei(4);
        j++;
    }
    tetramers_vbo.bind();
    tetramers_vbo.allocate(tetrameroutline, int(4*j*sizeof(tetramerimage)));
    tetramers_vbo.release();
    bShowTetramers = true;
    showTetramersAct->setText("Hide Tetramers {F2}");
}
void RyRFit::calcTetramer(Tetramer tmer, QVector3D tcolor, tetramerimage *tmi)
{
    double angleinradians = tmer.angle*degtorad+fortyfivedeg;
    double tdiag = tetramerdiag/ImageScale;
    float x1 = float(tdiag * cos (angleinradians));
    float y1 = float(tdiag * sin (angleinradians));
    float xpos = tmer.xcentre;
    float ypos = tmer.ycentre;
    tetramerimage td;
    td.vpos = QVector2D(xpos + x1, ypos + y1); td.linecolour = tcolor;
    tmi[imageindex++] = td;
    td.vpos = QVector2D(xpos - y1, ypos + x1);
    tmi[imageindex++] = td;
    td.vpos = QVector2D(xpos - x1, ypos - y1);
    tmi[imageindex++] = td;
    td.vpos = QVector2D(xpos + y1, ypos - x1);
    tmi[imageindex++] = td;
    return;
}
void RyRFit::loadSingleTetramerData()
{
    imageindex = 0;
    calcTetramer(ntm,PlacingColour, SingleTetramer);

    singletetramer_vbo.bind();
    singletetramer_vbo.allocate(SingleTetramer,4*sizeof(tetramerimage));
    singletetramer_vbo.release();
    update();
}

//************************************************************************
//*
//*  Section to handle tetramers
//*
//************************************************************************

void RyRFit::ChangeTetramerWidth()
{
    if(bAddTetramer || bClassifyTetramer || bModifyTetramer)
    {
        emit AlertMsg(" Please complete adding, classifying or modifing tetramer before changing width",'r');
        return;
    }
    bool ok;
    double tsize = QInputDialog::getDouble(nullptr, "Change Tetramerwidth",
                                         "Tetramer width (nm):", tetramersize, 24.0, 30.0, 1, &ok);

    if(!ok)
      return;
    tetramersize = tsize;
    tetramerwidth = tetramersize;
    tetramerdiag = tetramerwidth/sqrt2;
    loadTetramerData();
    update();
}
void RyRFit::addTetramer()
{
    if(bAddTetramer || bClassifyTetramer || bModifyTetramer)
    {
        emit AlertMsg(" Please complete adding, classifying or modifing a tetramer before adding another one",'r');
        return;
    }
    if(abs(fZoom - 1.0 ) > FLT_EPSILON)
    {
        ZoomNote();
        return;
    }
    setCursor(Qt::CrossCursor);
    bShowTetramers=true;
    bAddTetramer = true;
    bPlacingTetramer=false;
    bDisplayNND = false;
    emit AlertMsg(" Adding a tetramer",'b');
}
void RyRFit::modifyTetramer()
{
    if(bAddTetramer || bClassifyTetramer || bModifyTetramer)
    {
        emit AlertMsg(" Please complete modifying, classifying or adding a tetramer before modifying another one",'r');
        return;
    }
    if(nNoTetramers == 0)
    {
        emit AlertMsg(" No tetramers to modify",'r');
        return;
    }
    if(abs(fZoom - 1.0 ) > FLT_EPSILON)
    {
        ZoomNote();
        return;
    }
    setCursor(Qt::CrossCursor);
    bModifyTetramer = true;
    bDisplayNND = false;
    emit AlertMsg(" Modifying a tetramer",'b');
}
void RyRFit::classifyTetramer()
{
    if(nNoTetramers == 0)
    {
        emit AlertMsg(" No tetramers to classify",'r');
        return;
    }
    if(bModifyTetramer || bAddTetramer)
    {
        emit AlertMsg(" Please complete modifying, classifying or adding a tetramer before classifying another one",'r');
        return;
    }
    if(abs(fZoom - 1.0 ) > FLT_EPSILON)
    {
        ZoomNote();
        return;
    }
    setCursor(Qt::CrossCursor);
    bClassifyTetramer = true;
    bDisplayNND = false;
}
void RyRFit::deleteTetramer()
{
    if(abs(fZoom - 1.0 ) > FLT_EPSILON)
    {
        ZoomNote();
        return;
    }
    if(bAddTetramer)
    {
        bAddTetramer = false;
        bPlacingTetramer = false;
        emit AlertMsg(QString("Tetramer not added"),'r');
    }
    if(bModifyTetramer)
    {
        if(nBeingModified > -1)
        {
            em_interface::tm.erase(em_interface::tm.begin()+nBeingModified);
            nBeingModified = -1;
            bModifyTetramer = false;
            loadTetramerData();
        }
        emit AlertMsg(QString("Deleted tetramer #%1").arg(ntm.tno),'m');
    }
    bSavedTetFile = false;
    bCalcNearestNeighbours = true;
    update();
}
void RyRFit::saveTetramer()
{
    if(bAddTetramer)
    {
        ntm.classification = 'u';
        ntm.tno = tno++;
        bAddTetramer = false;
        bPlacingTetramer = false;
        em_interface::tm.push_back(ntm);
        emit AlertMsg(QString("Added tetramer #%1").arg(ntm.tno),'m');
    }
    if(bModifyTetramer)
    {
        em_interface::tm[nBeingModified] = ntm;
        bModifyTetramer = false;
        nBeingModified = -1;
        emit AlertMsg(QString("Modified tetramer #%1").arg(ntm.tno),'m');
    }
    loadTetramerData();
    bSavedTetFile = false;
    bShowTetramers = true;
    bCalcNearestNeighbours = true;
    update();
}
void RyRFit::ZoomNote()
{
    AlertMsg("Currently, tetramer addition, modification, classification<br>and deletion can only be done with Zoom = 1.0",'r');
}
void RyRFit::tetramerClassification(char c)
{
/*************** classification *************
     c = checkerboard
     s = side by side
     b = both checkerboard and side by side
     i = isolated
     u = unclassified
*********************************************/
    char ttype[] = {'c', 's', 'b', 'i', 'u'};
    QStringList classification{"Checkerboard", "Side-by-Side", "Both", "Isolated", "Unclassified"};
    int k = -1;
    for(int i = 0; i < 5; i++)
    {
        if(c == ttype[i])
        {
            k = i;
            break;
        }
    }
    if(k == -1)
        k=4;

    emit AlertMsg(QString("Tetramer #%1 classified as %2").arg(em_interface::tm[uint(nBeingClassified)].tno).arg(classification.at(k)),'m');
    em_interface::tm[uint(nBeingClassified)].classification = c;
    nBeingClassified = -1;
    bClassifyTetramer = false;
    bSavedTetFile = false;
    loadTetramerData();
    update();
}
void RyRFit::changeTetramerHighlight()
{
    bShadow = !bShadow;
    if(bShadow)
       changeTetramerHighlightAct->setText("Tetramer Boundary Highlight {F4}");
    else
       changeTetramerHighlightAct->setText("Tetramer Shadow Highlight {F4}");
    update();
}
void RyRFit::showExtent()
{
    bShowArea = !bShowArea;
    if(bShowArea)
        calculateArea();
    update();
}
bool RyRFit::findTetramer(Point_2 posn)
{
    double tmeas= tetramerwidth*tetramerwidth/4.0;

    if(bAddTetramer)
    {
        double xdiff = (ntm.xcentre - posn.x());
        double ydiff = (ntm.ycentre - posn.y());
        double dist = xdiff*xdiff + ydiff*ydiff;
        if (dist < tmeas)
        {
            loadSingleTetramerData();
        }
    }
    else
    {
        for (uint k = 0; k < nNoTetramers; k++)
        {

            double xdiff = (em_interface::tm[k].xcentre - posn.x());
            double ydiff = (em_interface::tm[k].ycentre - posn.y());
            double dist = xdiff*xdiff + ydiff*ydiff;
            if (dist < tmeas)
            {
                if(bModifyTetramer)
                    nBeingModified = int(k);

                if(bClassifyTetramer)
                    nBeingClassified = int(k);

                ntm=em_interface::tm[k];
                if(bModifyTetramer)
                    emit AlertMsg(QString("Modifying tetramer #%1").arg(ntm.tno),'b');
                if(bClassifyTetramer)
                    emit AlertMsg(QString("Classifying tetramer #%1").arg(ntm.tno),'b');

                loadSingleTetramerData();
                loadTetramerData();
                update();
                break;
            }
        }

        if(nBeingModified == -1 && nBeingClassified == -1)
        {
            bClassifyTetramer = bModifyTetramer = false;
            emit AlertMsg("Cannot find tetramer to be modified or classified",'r');
            return false;
        }
    }
    return true;
}
void RyRFit::calculateArea()
{
    nNoTetramers = uint(em_interface::tm.size());
    if(nNoTetramers < 2)
    {
        emit AlertMsg("Too few tetramers to calculate area",'r');
        bDisplayHulls = false;
        return;
    }
    double x[4], y[4];
    double tdiag;

    std::vector <APoint> PixelPosn;

    tdiag = tetramerdiag/ImageScale;
    for(uint j = 0; j < nNoTetramers; j++)
    {
        float angleinradians = em_interface::tm[j].angle*degtorad+fortyfivedeg;

        double x1 = tdiag * cos (angleinradians);
        double y1 = tdiag * sin (angleinradians);
        double xpos = em_interface::tm[j].xcentre;
        double ypos = em_interface::tm[j].ycentre;
        x[0]=xpos + x1;
        y[0]=ypos + y1;
        x[1]=xpos - y1;
        y[1]=ypos + x1;
        x[2]=xpos - x1;
        y[2]=ypos - y1;
        x[3]=xpos + y1;
        y[3]=ypos - x1;

        PixelPosn.push_back(APoint(x[0],y[0]));
        //        PixelPosn.push_back(APoint((x[0]+x[1])/2,(y[0]+y[1])/2));
        PixelPosn.push_back(APoint(x[1],y[1]));
        //        PixelPosn.push_back(APoint((x[1]+x[2])/2,(y[1]+y[2])/2));
        PixelPosn.push_back(APoint(x[2],y[2]));
        //        PixelPosn.push_back(APoint((x[2]+x[3])/2,(y[2]+y[3])/2));
        PixelPosn.push_back(APoint(x[3],y[3]));
        //        PixelPosn.push_back(APoint((x[3]+x[0])/2,(y[3]+y[0])/2));
    }
    std::sort(PixelPosn.begin(), PixelPosn.end(), RyRFit::PixelPosnLessThan);

// calculate convex hull for all the PixelPosn points

    std::vector<APoint> convex;
    CGAL::convex_hull_2(PixelPosn.begin(), PixelPosn.end(), std::back_inserter(convex));
    Polygon_2 q;
    for (std::vector<APoint>::iterator it = convex.begin() ; it != convex.end(); ++it)
        q.push_back(*it);

    totalConvexArea = q.area()*PixelSize*PixelSize;
    totalTetramerArea = tetramersize*tetramersize*nNoTetramers;
    percentTetramerAreaConvex = 100.0*totalTetramerArea/totalConvexArea;
    TetramerDensityConvex = nNoTetramers/totalConvexArea;

// load hulls

    uint totalHullPnts = uint(convex.size());
//    emit AlertMsg(QString("Total Points from Convex Hull = %1").arg(totalHullPnts),'b' );

    if(hullpts != nullptr)
        delete [] hullpts;

    hullpts = new QVector2D[totalHullPnts];

    hl_count = GLsizei(totalHullPnts);
    for(uint j4=0; j4 < totalHullPnts; j4++)
       hullpts[j4] = QVector2D(convex[j4].x(), convex[j4].y());

    hull_vbo.bind();
    hull_vbo.allocate(hullpts, int(totalHullPnts * sizeof(QVector2D)));
    hull_vbo.release();

// calculate alpha shapes

    double nmlimit = 60;
    double cutoff = nmlimit/PixelSize;
    alphashape.clear();

// See if there is more than one group of tetramers
// quick and dirty - since there are never two groups in y only check x.

    uint noAlphas = 1;
    for(unsigned int j = 1; j < PixelPosn.size(); j++)
    {
        double xdiff = PixelPosn[j].x() - PixelPosn[j-1].x();
        if(xdiff > cutoff)
           noAlphas++;
    }

    if(alphapts != nullptr)
        delete [] alphapts;

    totalAlphaArea = 0;
    uint totalAlphaSegs = 0;
    if(noAlphas == 1)
    {
       totalAlphaSegs = FitShape(PixelPosn);
       totalAlphaArea = AreaAlpha;
    }
    else
    {
       std::vector <APoint>* PixelGroups = new std::vector<APoint>[noAlphas];
       int ng = 0;
       PixelGroups[ng].push_back(PixelPosn[0]);
       for(unsigned int j = 1; j < PixelPosn.size(); j++)
       {
          PixelGroups[ng].push_back(PixelPosn[j-1]);
          double xdiff = PixelPosn[j].x() - PixelPosn[j-1].x();
          if(xdiff > cutoff)
             ng++;
       }
       PixelGroups[ng].push_back(PixelPosn[uint(PixelPosn.size()-1)]);

       for(uint m = 0; m < noAlphas; m++)
       {
           uint nosegs = FitShape(PixelGroups[m]);
           totalAlphaSegs += nosegs;
           totalAlphaArea += AreaAlpha;
       }
       delete [] PixelGroups;
    }

    percentTetramerAreaAlpha = 100.0*totalTetramerArea/totalAlphaArea;
    TetramerDensityAlpha = nNoTetramers/totalAlphaArea;

// Load alpha shapes

//    emit AlertMsg(QString("Total Segs from Alpha fit = %1").arg(totalAlphaSegs),'b' );
    uint totalAlphaPnts = 2*totalAlphaSegs;

    alphapts = new QVector2D[totalAlphaPnts];

    uint ich=0;
    for(uint j4=ich; j4 < totalAlphaSegs; j4++)
    {
          QVector2D ps = QVector2D(alphashape[j4].source().x(), alphashape[j4].source().y());
          QVector2D qs = QVector2D(alphashape[j4].target().x(), alphashape[j4].target().y());
          alphapts[ich++] = ps;
          alphapts[ich++] = qs;
   //       emit AlertMsg(QString("Alpha: (%1, %2) to (%3, %4)").arg(ps.x()).arg(ps.y()).arg(qs.x()).arg(qs.y()),'r');
    }

    al_count = ich;
    alpha_vbo.bind();
    alpha_vbo.allocate(alphapts, int(totalAlphaPnts * sizeof(QVector2D)));
    alpha_vbo.release();

    bDisplayHulls = true;

    update();
}
uint RyRFit::FitShape(std::vector<APoint> PixelGroup)
{
    std::vector <Segment> localsegments;
    Alpha_shape_2 A(PixelGroup.begin(), PixelGroup.end(), FT(1000), Alpha_shape_2::REGULARIZED);
    for(Alpha_shape_edges_iterator it =  A.alpha_shape_edges_begin(); it != A.alpha_shape_edges_end(); ++it)
    {
      localsegments.push_back(A.segment(*it));
      alphashape.push_back(A.segment(*it));
    }

// Order local segments
    uint segsize=uint(localsegments.size());
    for(uint k = 0; k < segsize; k++)
    {
       for(uint j=k+1; j < segsize; j++ )
       {
          if(localsegments[k].target() == localsegments[j].source())
          {
           if (j != k+1)
           {
             Segment temp = localsegments[k+1];
             localsegments[k+1] = localsegments[j];
             localsegments[j]=temp;
           }
           break;
          }
       }
    }

    Polygon_2 p;
    for(uint k = 0; k < segsize; k++)
        p.push_back(localsegments[k].source());

    AreaAlpha = p.area()*PixelSize*PixelSize;

    return segsize;
}
void RyRFit::calculateNearestNeighbours()
{
    NNDtet.clear();
    uint nTetramers = uint(em_interface::tm.size());
    for(uint j = 0; j < nTetramers; j++)
    {
        Point_2 tmj = Point_2(em_interface::tm[j].xcentre, em_interface::tm[j].ycentre);
        double xpos = tmj.x();
        double ypos = tmj.y();

        double nndmin = 10000000;
        NNDval a;
        a.NNDStart = Point_2(xpos,ypos);
        a.classification = em_interface::tm[j].classification;

        for(uint i = 0; i < nTetramers; i++)
        {
            if(i == j) continue;
            Point_2 tmi = Point_2(em_interface::tm[i].xcentre, em_interface::tm[i].ycentre);

            double xd = xpos-tmi.x();
            double yd = ypos-tmi.y();
            double dist=xd*xd + yd*yd;
            nndmin = qMin(nndmin,dist);
            if(std::abs(dist - nndmin) < DBL_EPSILON)
            {
                a.NND = sqrt(nndmin)*PixelSize;
                a.NNDEnd = tmi;
            }
        }
        NNDtet.push_back(a);
        bDisplayNND = true;
        update();
    }
}
void RyRFit::showNearestNeighbours()
{
    nNoTetramers = uint(em_interface::tm.size());
    if(nNoTetramers < 2)
    {
        emit AlertMsg("Too few tetramers to calculate nearest neighbours",'r');
        bDisplayNND = false;
        return;
     }

    bDisplayNND = !bDisplayNND;
    if(bDisplayNND)
    {
      calculateNearestNeighbours();
      showNearestNeighboursAct->setText("Hide Nearest Neighbours {n}");
    }
    else
      showNearestNeighboursAct->setText("Show Nearest Neighbours {n}");

    update();
}
void RyRFit::showRedTetramers()
{
    bRedColourOnly = !bRedColourOnly;
    if(bRedColourOnly)
       showRedTetramersAct->setText("Classification Colours {F3}");
    else
       showRedTetramersAct->setText("Red Tetramers {F3}");

    loadTetramerData();
    update();
}
void RyRFit::displayTetramers()
{
     nNoTetramers = uint(em_interface::tm.size());
     if(nNoTetramers < 1)
     {
        emit AlertMsg("No tetramers to display",'r');
        return;
     }
     bShowTetramers = !bShowTetramers;
     if(bShowTetramers)
     {
         showTetramersAct->setText("Hide Tetramers {F2}");
         loadTetramerData();
     }
     else
     {
         showTetramersAct->setText("Show Tetramers {F2}");
         if(bDisplayNND)
         {
             showNearestNeighboursAct->setText("Show Nearest Neighbours {n}");
             bDisplayNND =false;
         }
     }
     update();
}
void RyRFit::hideEMImage()
{
    bHideEMImage = !bHideEMImage;
    if(bHideEMImage) {
        bLookAhead = false;
        hideEMImageAct->setText("Show EM Image {h}");
    }
    else {
        if (nLookAhead != 0)
           bLookAhead = true;
        hideEMImageAct->setText("Hide EM Image {h}");
    }
    update();
}
void RyRFit::FlipImage()
{
    fFlipImage = -fFlipImage;
    update();
}

//*****************************************
//* End Section to deal with Tetramers
//*****************************************
void RyRFit::imageZoomIn()
{
    fOldZoom = fZoom;
    if(fZoom >= 1.0f)
        fZoom += fZoomDelta;

    if (fZoom <= 0.0f)
    {
        emit AlertMsg(QString("Zoom is zero - reset to 1.0"),'r');
        fZoom = 1.0f;
    }
     ChangeSize();
}
void RyRFit::imageZoomOut()
{
    fOldZoom = fZoom;
     if(fZoom >= 1.0f)
        fZoom -= fZoomDelta;
     else
        fZoom -= 0.2f;


     if (fZoom <= 0.0f)
     {
        emit AlertMsg(QString("Zoom is zero - reset to 1.0"),'r');
        fZoom = 1.0f;
     }
     ChangeSize();
}
void RyRFit::ChangeSize()
{
    ImageXdim = fZoom*InitXdim;
    ImageYdim = fZoom*InitYdim;
    resize(ImageXdim, ImageYdim);
    PixelSize = ImageScale/fZoom;
    changeProjection(fZoom, fZoom);
    emit AlertMsg(QString("Zoom = %1 - PixelSize = %2 nm").arg(fZoom).arg(PixelSize,0,'f',2),'m');
    changeScalingandTranslation(ImageOffset.x(),ImageOffset.y());
    if(bLinePlot)
        bLinePlot = !bLinePlot;

    if(bScaleBar)
        CalculateScaleBar();
    update();
}
void RyRFit::imageFirstPlane()
{
    ImageNo=nZmin;
    update();
}
void RyRFit::imageLastPlane()
{
    ImageNo=nZmax;
    update();
}
void RyRFit::imageNextPlane()
{
    ImageNo++;
    ImageNo = (ImageNo > nZmax) ? nZmin : ImageNo;
    update();
}
void RyRFit::imagePrevPlane()
{
    ImageNo--;
    ImageNo = (ImageNo < nZmin) ? nZmax : ImageNo;
    update();
}
void RyRFit:: saveTetramerFiles()
{
    nNoTetramers = uint(em_interface::tm.size());
    if(bSavedTetFile)
        return;

    emit AlertMsg(QString("Saving tetramer file: %1").arg(em_interface::TetramerFile),'m');

    QFile file(em_interface::TetramerFile);
    if(!file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        emit AlertMsg(QString("Tetramer File error %1").arg(file.errorString()),'r');
        return;
    }
    QTextStream out(&file);

    out << "scale=" << ImageScale << "\n";

    for (uint jj = 0; jj < nNoTetramers; jj++)
        out << em_interface::tm[jj].xcentre << ' '<< em_interface::tm[jj].ycentre << ' ' << em_interface::tm[jj].angle << ' ' << em_interface::tm[jj].classification <<"\n";

    file.close();
    bSavedTetFile = true;
    Save_DisplayNNDFiles();
}
void RyRFit::Save_DisplayNNDFiles()
{
    nNoTetramers = uint(em_interface::tm.size());
    if(nNoTetramers < 2)
    {
        emit AlertMsg("Too few tetramers to calculate Nearest Neighbours or Area",'r');
        return;
    }
    int nNoUnclassified = 0;
    int nNoCheckerboard = 0;
    int nNoSidebySide = 0;
    int nNoIsolated = 0;
    int nNoBoth = 0;
    for (uint jj = 0; jj < nNoTetramers; jj++)
    {

        switch(em_interface::tm[jj].classification)
        {
        case 'u':
            nNoUnclassified++;
            break;
        case 'c':
            nNoCheckerboard++;
            break;
        case 's':
            nNoSidebySide++;
            break;
        case 'i':
            nNoIsolated++;
            break;
        case 'b':
            nNoBoth++;
            break;
        }
    }


    calculateArea();
    bShowArea = true;

    calculateNearestNeighbours();

    emit AlertMsg(QString("Total tetramers = %1").arg(nNoTetramers),'b');
    if(nNoCheckerboard > 0)
        emit AlertMsg(QString("No. checkerboard = %1").arg(nNoCheckerboard),'b');
    if(nNoSidebySide > 0)
        emit AlertMsg(QString("No. side by side = %1").arg(nNoSidebySide),'b');
    if(nNoIsolated > 0)
        emit AlertMsg(QString("No. Isolated = %1").arg(nNoIsolated),'b');
    if(nNoBoth > 0)
        emit AlertMsg(QString("No. Both = %1").arg(nNoBoth),'b');
    if(nNoUnclassified > 0)
        emit AlertMsg(QString("No. Unclassified = %1").arg(nNoUnclassified),'b');

    emit AlertMsg("Nearest Neighbour distances",'b');

    if(nNoCheckerboard > 0)
    {
        emit AlertMsg(QString("Checkerboard: = %1").arg(nNoCheckerboard),'b');
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'c')
                emit AlertMsg(QString("%1").arg(NNDtet[k].NND,0,'f',1),'b');
        }
    }
    if(nNoSidebySide > 0)
    {
        emit AlertMsg(QString("Side by side: = %1").arg(nNoSidebySide),'b');
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 's')
                emit AlertMsg(QString("%1").arg(NNDtet[k].NND,0,'f',1),'b');
        }
    }
    if(nNoBoth > 0)
    {
        emit AlertMsg(QString("Both: = %1").arg(nNoBoth),'b');
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'b' )
                emit AlertMsg(QString("%1").arg(NNDtet[k].NND,0,'f',1),'b');
        }
    }
    if(nNoIsolated > 0)
    {
        emit AlertMsg(QString("Isolated: = %1").arg(nNoIsolated),'b');
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'i')
                emit AlertMsg(QString("%1").arg(NNDtet[k].NND,0,'f',1),'b');
        }
    }
    if(nNoUnclassified > 0)
    {
        emit AlertMsg(QString("Unclassified: = %1").arg(nNoUnclassified),'b');
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'u')
                emit AlertMsg(QString("%1").arg(NNDtet[k].NND,0,'f',1),'b');
        }
    }

    emit AlertMsg(QString("Total tetramers = %1").arg(nNoTetramers),'b');
    emit AlertMsg(QString("Convex Hull: Tetramers cover %1% of the total area - Density = %2 nm**-2").arg(percentTetramerAreaConvex,0,'f',2).arg(TetramerDensityConvex,0,'e',3),'b');
    emit AlertMsg(QString("Alpha Shape: Tetramers cover %1% of the total area - Density = %2 nm**-2").arg(percentTetramerAreaAlpha,0,'f',2).arg(TetramerDensityAlpha,0,'e',3),'b');

    emit AlertMsg(QString("Saving nearest neighbour file : %1 ...").arg(em_interface::NNDFile),'b');

    QFile nnfile(em_interface::NNDFile);
    if(!nnfile.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        emit AlertMsg(QString("Error %1").arg(nnfile.errorString()),'r');
        return;
    }
    QTextStream nnout(&nnfile);

    nnout << "Total tetramers = " << nNoTetramers << "\n";
    if(nNoCheckerboard > 0)
        nnout << "No. checkerboard = " << nNoCheckerboard << "\n";
    if(nNoSidebySide > 0)
        nnout << "No. side by side = " << nNoSidebySide << "\n";
    if(nNoIsolated > 0)
        nnout << "No. Isolated = " << nNoIsolated << "\n";
    if(nNoBoth > 0)
        nnout << "No. Both = " << nNoBoth << "\n";
    if(nNoUnclassified > 0)
        nnout << "No. Unclassified = " << nNoUnclassified << "\n";
    nnout.setRealNumberPrecision(1);

    if(nNoCheckerboard > 0)
    {
        nnout << "\nCheckerboard\n";
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'c')
                nnout  << Qt::fixed <<  NNDtet[k].NND << "\n";
        }
    }
    if(nNoSidebySide > 0)
    {
        nnout << "\nSide by side\n";
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 's')
                nnout  << Qt::fixed <<  NNDtet[k].NND << "\n";
        }
    }
    if(nNoBoth > 0)
    {
        nnout << "\nBoth\n";
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'b' )
                nnout  << Qt::fixed <<  NNDtet[k].NND << "\n";        }
    }
    if(nNoIsolated > 0)
    {
        nnout << "\nIsolated\n";
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'i')
                nnout  << Qt::fixed <<  NNDtet[k].NND << "\n";
        }
    }
    if(nNoUnclassified > 0)
    {
        nnout << "\nUnclassified\n";
        for(uint k= 0; k < nNoTetramers; k++)
        {
            if(NNDtet[k].classification == 'u')
                nnout  << Qt::fixed <<  NNDtet[k].NND << "\n";
        }
    }

    nnout.setRealNumberPrecision(2);
    nnout << "\nConvex Hull: Tetramers cover " << Qt::fixed << percentTetramerAreaConvex  << " % of the total area - Density = ";
    nnout.setRealNumberPrecision(3);
    nnout << Qt::scientific << TetramerDensityConvex  << " nm**-2\n";
    nnout.setRealNumberPrecision(2);
    nnout << "Alpha Shape: Tetramers cover " << Qt::fixed << percentTetramerAreaAlpha  << " % of the total area - Density = ";
    nnout.setRealNumberPrecision(3);
    nnout << Qt::scientific << TetramerDensityAlpha  << " nm**-2\n";
    nnfile.close();
}
void RyRFit::createMenus()
{
    // Image Menu

    tetramerMenu=imageMenu->addMenu(tr("Tetramers"));
    imageMenu->addSeparator();
    imageMenu->addAction(LineAct);
    imageMenu->addAction(addScaleBarAct);
    imageMenu->addSeparator();
    imageMenu->addAction(createScreenShotAct);
    imageMenu->addSeparator();
    imageMenu->addAction(FlipImageAct);
    imageMenu->addAction(hideEMImageAct);
    imageMenu->addAction(changeLookAheadAct);
    imageMenu->addAction(LookAheadAct);
    imageMenu->addAction(changeImageScalingAct);
    imageMenu->addAction(changePaletteAct);
    imageMenu->addSeparator();
    imageMenu->addAction(ZoomInAct);
    imageMenu->addAction(ZoomOutAct);
    imageMenu->addSeparator();
    imageMenu->addAction(showHelpAct);
    imageMenu->addSeparator();
    imageMenu->addAction(QuitAct);

    tetramerMenu->addAction(addTetramerAct);
    tetramerMenu->addAction(modifyTetramerAct);
    tetramerMenu->addAction(saveTetramerAct);
    tetramerMenu->addSeparator();
    tetramerMenu->addAction(showTetramersAct);
    tetramerMenu->addAction(showRedTetramersAct);
    tetramerMenu->addAction(changeTetramerHighlightAct);
    tetramerMenu->addAction(ChangeTetramerWidthAct);
    tetramerMenu->addSeparator();
    tetramerMenu->addAction(OutputNNDAct);
    tetramerMenu->addAction(saveTetFileAct);
    tetramerMenu->addSeparator();
    tetramerMenu->addAction(showTetramerExtentAct);
    tetramerMenu->addAction(showNearestNeighboursAct);
}
void RyRFit::createActions()
{	
    // image menu actions

    addTetramerAct = new QAction(tr("Add {a}"),this);
    connect(addTetramerAct, SIGNAL(triggered()), this, SLOT(addTetramer()));

    modifyTetramerAct = new QAction(tr("Modify {m}"),this);
    connect(modifyTetramerAct, SIGNAL(triggered()), this, SLOT(modifyTetramer()));

    saveTetramerAct = new QAction(tr("Save {s}"),this);
    connect(saveTetramerAct, SIGNAL(triggered()), this, SLOT(saveTetramer()));

    hideEMImageAct = new QAction(tr("Hide EM Image {h}"), this);
    connect(hideEMImageAct, SIGNAL(triggered()), this , SLOT(hideEMImage()));

    showTetramerExtentAct = new QAction(tr("Show Hull/Alpha Shape {r}"),this);
    connect(showTetramerExtentAct, SIGNAL(triggered()), this, SLOT(showExtent()));

    showNearestNeighboursAct = new QAction(tr("Show Nearest Neighbours {n}"),this);
    connect(showNearestNeighboursAct, SIGNAL(triggered()), this, SLOT(showNearestNeighbours()));

    showHelpAct = new QAction(tr("Help {F1}"),this);
    connect(showHelpAct, SIGNAL(triggered()), this, SIGNAL(showHelp()));

    showTetramersAct = new QAction(tr("Hide Tetramers {F2}"),this);
    connect(showTetramersAct, SIGNAL(triggered()), this, SLOT(displayTetramers()));

    showRedTetramersAct = new QAction(tr("Red Tetramers {F3}"),this);
    connect(showRedTetramersAct, SIGNAL(triggered()), this, SLOT(showRedTetramers()));

    changeTetramerHighlightAct = new QAction(tr("Tetramer Shadow Highlight {F4}"), this);
    connect(changeTetramerHighlightAct, SIGNAL(triggered()), this, SLOT(changeTetramerHighlight()));

    saveTetFileAct = new QAction(tr("Save Tetramer Files {F5}"),this);
    connect(saveTetFileAct, SIGNAL(triggered()), this, SLOT(saveTetramerFiles()));

    addScaleBarAct = new QAction(tr("Add Scale Bar (size in nm) {F6}"),this);
    connect(addScaleBarAct, SIGNAL(triggered()), this, SLOT(getScaleBarSize()));

    createScreenShotAct = new QAction(tr("Save TIFF screenshot {F7}"),this);
    connect(createScreenShotAct, SIGNAL(triggered()), this, SLOT(CreateScreenShot()));

    LookAheadAct = new QAction(tr("Look Ahead {l}"), this);
    connect(LookAheadAct, SIGNAL(triggered()), this, SLOT(LookAhead()));

    changeLookAheadAct = new QAction(tr("Change Look Ahead {k}"), this);
    connect(changeLookAheadAct, SIGNAL(triggered()), this, SLOT(changeLookAhead()));

    changePaletteAct = new QAction(tr("Change Palette {F8}"), this);
    connect(changePaletteAct, SIGNAL(triggered()), this, SLOT(changePalette()));

    changeImageScalingAct = new QAction(tr("Change Image Scaling {F9}"), this);
    connect(changeImageScalingAct, SIGNAL(triggered()), this, SLOT(changeImageScaling()));

    OutputNNDAct = new QAction(tr("Display NNDs {F10}"), this);
    connect(OutputNNDAct, SIGNAL(triggered()), this, SLOT(OutputNNDs()));

    ChangeTetramerWidthAct = new QAction(tr("Change Tetramer Width {F11}"), this);
    connect(ChangeTetramerWidthAct, SIGNAL(triggered()), this, SLOT(ChangeTetramerWidth()));

    FlipImageAct = new QAction(tr("Flip Image {F12}"), this);
    connect(FlipImageAct, SIGNAL(triggered()), this, SLOT(FlipImage()));

    LineAct = new QAction(tr("Measure Distance {d}"),this);
    connect(LineAct, SIGNAL(triggered()), this, SLOT(imageLine()));

    ZoomInAct = new QAction(tr("Zoom In {+}"),this);
    connect(ZoomInAct, SIGNAL(triggered()), this, SLOT(imageZoomIn()));

    ZoomOutAct = new QAction(tr("Zoom Out {-}"),this);
    connect(ZoomOutAct, SIGNAL(triggered()), this, SLOT(imageZoomOut()));

    QuitAct = new QAction(tr("Quit  {esc}"),this);
    connect(QuitAct, SIGNAL(triggered()), this, SLOT(CloseWindow()));
}
void RyRFit::CreateScreenShot()
{
    CreateTIFF(ImageXdim, ImageYdim, BackBuffer, ScreenDPI, fZoom);
}
void RyRFit:: CreateTIFF(int XSize, int YSize, int imagetype, int DPI, double Magnification)
{
    double ActualPixelSize = PixelSize;
    if(imagetype == BackBuffer)  // Screenshot
        emit AlertMsg(QString("Creating Screenshot image (%1 x %2) as TIFF ....").arg(XSize).arg(YSize),' ');
    else
    {
        ActualPixelSize =  ImageScale/Magnification;
        emit AlertMsg(QString("Creating FBO image (%1 x %2) as TIFF ....").arg(XSize).arg(YSize),' ');
    }
    int nNoRGBABytes = XSize*YSize*4;

    GLubyte* ScreenData=nullptr;
    try{
        ScreenData = new GLubyte[size_t(nNoRGBABytes)];
    }
    catch (std::bad_alloc& ba)
    {
        emit AlertMsg(QString("Unable to allocate memory for TIFF creation<br>Reason: %1").arg(ba.what()),'r');
        return;
    }
#ifdef WIN32
    QOpenGLContext* ctx;
    QSurface* ctsurf;
    if(imagetype == BackBuffer)
    {
        ctx = context();
        ctsurf = ctx->surface();
        ctx->swapBuffers(ctsurf);
    }
#endif

    glReadPixels(0, 0, XSize, YSize, GL_RGBA, GL_UNSIGNED_BYTE, ScreenData);
    GLenum err = glGetError();
    if (err != GL_NO_ERROR)
    {
        const char* errString = "something"; //reinterpret_cast<const char*> (gluErrorString (err));
        emit AlertMsg(QString("OpenGL Error  - %1 - %2 at glReadPixels").arg(err).arg(errString),'r');
        return;
    }
#ifdef WIN32
    if(imagetype == BackBuffer)
    {
        ctx->swapBuffers(ctsurf);
        makeCurrent();
    }
#endif
    QDateTime whenTIFFcreated(QDateTime::currentDateTime());
    QString DateTimeInfo=whenTIFFcreated.toString("yyyy:MM:dd hh:mm:ss");

    QFile qdata;
    QString fname = em_interface::TiffOutputRoot;
    QString OutputFile = QString("%1.tif").arg(fname);
    qdata.setFileName(OutputFile);
    if(qdata.exists())
    {
        int picno = 1;
        forever
        {
            OutputFile = QString("%1_%2.tif").arg(fname).arg(picno);
            qdata.setFileName(OutputFile);
            if(!qdata.exists())
                break;
            picno++;
        }
    }

    QString Description = QString("RyRFit image : Pixel size = %1 nm").arg(ActualPixelSize,0,'f',1);
    TiffImage Tiff_Image;
    Tiff_Image.setOutputType(TIFF_RGBA_8bit);
    Tiff_Image.setDim(uint32(XSize), uint32(YSize), 1);
    Tiff_Image.setRes(DPI,2);
    Tiff_Image.setBytePointer(ScreenData);
    Tiff_Image.setDateTime(qPrintable(DateTimeInfo));
    Tiff_Image.setOrigin(0,0);
    Tiff_Image.setSoftware("RyRFit, Moore Lab, UBC, Vancouver, Canada");
    Tiff_Image.CalculateMinMax();
    Tiff_Image.setDescription(Description);
    if(Tiff_Image.WriteTiff(OutputFile))
        emit AlertMsg(QString("Image File: %1 saved").arg(OutputFile),'b');
    else
        emit AlertMsg(QString("Unable to save image file"),'r');

    return;
}
